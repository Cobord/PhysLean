/-
Copyright (c) 2025 Joseph Tooby-Smith. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Matteo Cipollina, Joseph Tooby-Smith
-/
import PhysLean.Thermodynamics.Temperature.Basic
import Mathlib.MeasureTheory.Measure.ProbabilityMeasure
import Mathlib.Analysis.Calculus.ParametricIntegral
import PhysLean.Meta.Informal.SemiFormal
import PhysLean.Meta.Linters.Sorry
import Mathlib.Analysis.SpecialFunctions.Log.Summable
import Mathlib.MeasureTheory.Integral.Prod
import Mathlib.Order.Filter.AtTopBot.Basic
/-!

# Canonical Ensemble: General Theory

A canonical ensemble describes a physical system in thermal equilibrium with a heat bath at a
fixed temperature.

In this file we define the canonical ensemble, its partition function, the
probability of being in a given microstate, the mean energy, the entropy and
the Helmholtz free energy

We also define the addition of two canonical ensembles, and prove results related
to the properties of additions of canonical ensembles

We develop a general measure-theoretic framework designed to be applicable to both classical
continuous systems (like an ideal gas) and discrete systems (like a spin lattice).

## The Semi-Classical Framework

In classical statistical mechanics quantities like the partition function and entropy must be
dimensionless to be physically meaningful. A naive integration over a classical
phase space yields dimensionful quantities, leading to ambiguities (e.g., the Gibbs paradox).

Following the "semi-classical" approach (see references) we introduce a constant with
units of action (`phase_space_unit`, identified with Planck's constant `h`) and the number of
degrees of freedom (`dof`) to correctly normalize the phase space volume.

This file distinguishes between:
1.  **Mathematical quantities**: Raw results of integration over the given measure
    (e.g., `mathematicalPartitionFunction`, `differentialEntropy`).
2.  **Physical/Thermodynamic quantities**: Dimensionless, physically meaningful quantities derived
    from the mathematical ones using the semi-classical normalization
    (e.g., `partitionFunction`, `helmholtzFreeEnergy`, `thermodynamicEntropy`).

## Main Definitions

- `CanonicalEnsemble`: The core structure, including `energy`, `dof`, and `phase_space_unit`.
- `mathematicalPartitionFunction`: The raw integral of the Boltzmann factor, `‚à´ exp(-Œ≤E) dŒº`.
- `partitionFunction`: The dimensionless physical partition function, `Z = Z_math / h^dof`.
- `probability`: The probability density function.
- `meanEnergy`: The expectation value of the energy.
- `differentialEntropy`: The entropy defined as `-k_B ‚à´ œÅ log œÅ dŒº`, which can be negative.
- `helmholtzFreeEnergy`: The physical free energy `F = -k_B T log(Z)`.
- `thermodynamicEntropy`: The absolute physical entropy, defined via `S = (U - F) / T`.

## Key Theorems

- The relationship between the mathematical `helmholtzMathematicalFreeEnergy` and the physical
  `helmholtzFreeEnergy`.
- The connection between `thermodynamicEntropy` and `differentialEntropy`, showing
  they differ by a constant related to the `phase_space_unit`.
- The relationship between `helmholtzFreeEnergy` and `thermodynamicEntropy`.
- The Helmholtz identity: `F = U - TS`.

##¬†References
- L. D. Landau and E. M. Lifshitz, *Statistical Physics, Part 1*.
- https://www.damtp.cam.ac.uk/user/tong/statphys/statmechhtml/S1.html#E23.
- https://www.damtp.cam.ac.uk/user/tong/statphys/two.pdf
-/

open MeasureTheory Real Temperature
open scoped Temperature

/-- A Canonical ensemble is described by a type `Œπ`, corresponding to the type of microstates,
and a map `Œπ ‚Üí ‚Ñù` which associates which each microstate an energy
and physical constants needed to define dimensionless thermodynamic quantities. -/
structure CanonicalEnsemble (Œπ : Type) [MeasurableSpace Œπ] : Type where
  /-- The energy of associated with a mircrostate of the canonical ensemble. -/
  energy : Œπ ‚Üí ‚Ñù
  /-- The number of degrees of freedom, used to make the partition function dimensionless.
  For a classical system of N particles in 3D, this is `3N`. For a system of N spins,
  this is typically `0` as the state space is already discrete. -/
  dof : ‚Ñï
  /-- The unit of action used to make the phase space volume dimensionless.
  This constant is necessary to define an absolute (rather than relative) thermodynamic
  entropy. In the semi-classical approach, this unit is identified with Planck's constant `h`.
  For discrete systems with a counting measure, this unit should be set to `1`. -/
  phase_space_unit : ‚Ñù := 1
  /-- Assumption that the phase space unit is positive. -/
  h_pos : 0 < phase_space_unit := by positivity
  energy_measurable : Measurable energy
  /-- The measure on the indexing set of microstates. -/
  Œº : MeasureTheory.Measure Œπ := by volume_tac
  [Œº_sigmaFinite : SigmaFinite Œº]

namespace CanonicalEnsemble
open Real Temperature

variable {Œπ Œπ1 : Type} [MeasurableSpace Œπ]
  [MeasurableSpace Œπ1] (ùìí : CanonicalEnsemble Œπ) (ùìí1 : CanonicalEnsemble Œπ1)

instance : SigmaFinite ùìí.Œº := ùìí.Œº_sigmaFinite

@[ext]
lemma ext {ùìí ùìí' : CanonicalEnsemble Œπ} (h_energy : ùìí.energy = ùìí'.energy)
    (h_dof : ùìí.dof = ùìí'.dof) (h_h : ùìí.phase_space_unit = ùìí'.phase_space_unit)
    (h_Œº : ùìí.Œº = ùìí'.Œº) : ùìí = ùìí' := by
  cases ùìí; cases ùìí'; simp_all

@[fun_prop]
lemma energy_measurable' : Measurable ùìí.energy := ùìí.energy_measurable

/-- The addition of two `CanonicalEnsemble`. The degrees of freedom are added.
Note: This is only physically meaningful if the two systems share the same `phase_space_unit`. -/
noncomputable instance {Œπ1 Œπ2 : Type} [MeasurableSpace Œπ1] [MeasurableSpace Œπ2] :
    HAdd (CanonicalEnsemble Œπ1) (CanonicalEnsemble Œπ2)
    (CanonicalEnsemble (Œπ1 √ó Œπ2)) where
  hAdd := fun ùìí1 ùìí2 => {
    energy := fun (i : Œπ1 √ó Œπ2) => ùìí1.energy i.1 + ùìí2.energy i.2
    dof := ùìí1.dof + ùìí2.dof
    phase_space_unit := ùìí1.phase_space_unit
    h_pos := ùìí1.h_pos
    Œº := ùìí1.Œº.prod ùìí2.Œº
    energy_measurable := by fun_prop
  }

/-- The canonical ensemble with no microstates. -/
def empty : CanonicalEnsemble Empty where
  energy := isEmptyElim
  dof := 0
  Œº := 0
  energy_measurable := by fun_prop

/-- Given a measurable equivalence `e : Œπ1 ‚âÉ·µê Œπ`, this is the corresponding canonical ensemble
on `Œπ1`. The physical properties (`dof`, `phase_space_unit`) are unchanged. -/
noncomputable def congr (e : Œπ1 ‚âÉ·µê Œπ) : CanonicalEnsemble Œπ1 where
  energy := fun i => ùìí.energy (e i)
  dof := ùìí.dof
  phase_space_unit := ùìí.phase_space_unit
  h_pos := ùìí.h_pos
  Œº := ùìí.Œº.map e.symm
  energy_measurable := by
    apply Measurable.comp
    ¬∑ fun_prop
    ¬∑ exact MeasurableEquiv.measurable e
  Œº_sigmaFinite := MeasurableEquiv.sigmaFinite_map e.symm

@[simp]
lemma congr_energy_comp_symmm (e : Œπ1 ‚âÉ·µê Œπ) :
    (ùìí.congr e).energy ‚àò e.symm = ùìí.energy := by
  funext i
  simp [congr]

/-- Scalar multiplication of `CanonicalEnsemble`, defined such that
`nsmul n ùìí` represents `n` non-interacting, distinguishable copies of the ensemble `ùìí`. -/
noncomputable def nsmul (n : ‚Ñï) (ùìí : CanonicalEnsemble Œπ) : CanonicalEnsemble (Fin n ‚Üí Œπ) where
  energy := fun f => ‚àë i, ùìí.energy (f i)
  dof := n * ùìí.dof
  phase_space_unit := ùìí.phase_space_unit
  h_pos := ùìí.h_pos
  Œº := MeasureTheory.Measure.pi fun _ => ùìí.Œº
  energy_measurable := by fun_prop

set_option linter.unusedVariables false in
/-- The microstates of a canonical ensemble. -/
@[nolint unusedArguments]
abbrev microstates (ùìí : CanonicalEnsemble Œπ) : Type := Œπ

/-! ## Properties of physical parameters -/

@[simp]
lemma dof_add (ùìí1 : CanonicalEnsemble Œπ) (ùìí2 : CanonicalEnsemble Œπ1) :
    (ùìí1 + ùìí2).dof = ùìí1.dof + ùìí2.dof := rfl

@[simp]
lemma phase_space_unit_add (ùìí1 : CanonicalEnsemble Œπ) (ùìí2 : CanonicalEnsemble Œπ1) :
    (ùìí1 + ùìí2).phase_space_unit = ùìí1.phase_space_unit := rfl

@[simp]
lemma dof_nsmul (n : ‚Ñï) : (nsmul n ùìí).dof = n * ùìí.dof := rfl

@[simp]
lemma phase_space_unit_nsmul (n : ‚Ñï) :
    (nsmul n ùìí).phase_space_unit = ùìí.phase_space_unit := rfl

@[simp]
lemma dof_congr (e : Œπ1 ‚âÉ·µê Œπ) :
    (ùìí.congr e).dof = ùìí.dof := rfl

@[simp]
lemma phase_space_unit_congr (e : Œπ1 ‚âÉ·µê Œπ) :
    (ùìí.congr e).phase_space_unit = ùìí.phase_space_unit := rfl

/-! ## The measure -/

lemma Œº_add : (ùìí + ùìí1).Œº = ùìí.Œº.prod ùìí1.Œº := rfl

lemma Œº_nsmul (n : ‚Ñï) : (nsmul n ùìí).Œº = MeasureTheory.Measure.pi fun _ => ùìí.Œº := rfl

lemma Œº_nsmul_zero_eq : (nsmul 0 ùìí).Œº = Measure.pi (fun _ => 0) := by
  simp [nsmul, Œº_nsmul]
  congr
  funext x
  exact Fin.elim0 x

/-!

## The energy of the microstates

-/

@[simp]
lemma energy_add_apply (i : microstates (ùìí + ùìí1)) :
    (ùìí + ùìí1).energy i = ùìí.energy i.1 + ùìí1.energy i.2 := rfl

@[simp]
lemma energy_nsmul_apply (n : ‚Ñï) (f : Fin n ‚Üí microstates ùìí) :
    (nsmul n ùìí).energy f = ‚àë i, ùìí.energy (f i) := rfl

@[simp]
lemma energy_congr_apply (e : Œπ1 ‚âÉ·µê Œπ) (i : Œπ1) :
    (ùìí.congr e).energy i = ùìí.energy (e i) := rfl

/-! ## Induction for nsmul -/

open MeasureTheory

lemma nsmul_succ (n : ‚Ñï) [SigmaFinite ùìí.Œº] : nsmul n.succ ùìí = (ùìí + nsmul n ùìí).congr
    (MeasurableEquiv.piFinSuccAbove (fun _ => Œπ) 0) := by
  ext1
  ¬∑ ext x
    simp only [Nat.succ_eq_add_one, energy_nsmul_apply, congr_energy_comp_symmm,
      MeasurableEquiv.piFinSuccAbove_apply, Fin.insertNthEquiv_zero, Fin.consEquiv_symm_apply,
      energy_add_apply, MeasurableEquiv.symm_apply_apply]
    exact Fin.sum_univ_succAbove (fun i => ùìí.energy (x i)) 0
  ¬∑ simp [Nat.succ_eq_add_one, Nat.succ_mul, dof_nsmul, add_comm, add_left_comm, add_assoc]
  ¬∑ simp
  ¬∑ refine Eq.symm (MeasureTheory.MeasurePreserving.map_eq ?_)
    refine MeasurePreserving.symm _ ?_
    exact MeasureTheory.measurePreserving_piFinSuccAbove (n := n) (fun _ => ùìí.Œº) 0

/-!

## Non zero nature of the measure

-/

instance [NeZero ùìí.Œº] [NeZero ùìí1.Œº] : NeZero (ùìí + ùìí1).Œº := by
  simp [Œº_add]
  refine { out := ?_ }
  rw [‚Üê @Measure.measure_univ_pos]
  have h1 : (ùìí.Œº.prod (ùìí1.Œº)) Set.univ =
      (ùìí.Œº Set.univ) * (ùìí1.Œº Set.univ) := by
    rw [‚Üê @Measure.prod_prod]
    simp
  rw [h1]
  exact NeZero.pos (ùìí.Œº Set.univ * ùìí1.Œº Set.univ)

instance Œº_neZero_congr [NeZero ùìí.Œº] (e : Œπ1 ‚âÉ·µê Œπ) :
    NeZero (ùìí.congr e).Œº := by
  refine { out := ?_ }
  rw [‚Üê @Measure.measure_univ_pos]
  simp only [Measure.measure_univ_pos, ne_eq]
  refine (Measure.map_ne_zero_iff ?_).mpr ?_
  ¬∑ fun_prop
  ¬∑ exact Ne.symm (NeZero.ne' _)

instance [NeZero ùìí.Œº] (n : ‚Ñï) : NeZero (nsmul n ùìí).Œº := by
  induction n with
  | zero =>
    rw [Œº_nsmul_zero_eq]
    rw [@neZero_iff]
    simp only [ne_eq]
    refine Measure.measure_univ_ne_zero.mp ?_
    simp
  | succ n ih =>
    rw [nsmul_succ]
    infer_instance

/-!

## The Boltzmann measure

-/

/-- The Boltzmann measure on the space of microstates. -/
noncomputable def ŒºBolt (T : Temperature) : MeasureTheory.Measure Œπ :=
  ùìí.Œº.withDensity (fun i => ENNReal.ofReal (exp (- T.Œ≤ * ùìí.energy i)))

instance (T : Temperature) : SigmaFinite (ùìí.ŒºBolt T) :=
  inferInstanceAs
    (SigmaFinite (ùìí.Œº.withDensity (fun i => ENNReal.ofReal (exp (- Œ≤ T * ùìí.energy i)))))

@[simp]
lemma ŒºBolt_add (T : Temperature) :
    (ùìí + ùìí1).ŒºBolt T = (ùìí.ŒºBolt T).prod (ùìí1.ŒºBolt T) := by
  simp_rw [ŒºBolt, Œº_add]
  rw [MeasureTheory.prod_withDensity]
  congr
  funext i
  rw [‚Üê ENNReal.ofReal_mul, ‚Üê Real.exp_add]
  simp only [energy_add_apply, neg_mul]
  ring_nf
  ¬∑ exact exp_nonneg _
  ¬∑ fun_prop
  ¬∑ fun_prop

lemma ŒºBolt_congr (e : Œπ1 ‚âÉ·µê Œπ) (T : Temperature) : (ùìí.congr e).ŒºBolt T =
    (ùìí.ŒºBolt T).map e.symm := by
  simp [congr, ŒºBolt]
  refine Measure.ext_of_lintegral _ fun œÜ hœÜ ‚Ü¶ ?_
  rw [lintegral_withDensity_eq_lintegral_mul‚ÇÄ]
  rw [lintegral_map, lintegral_map, lintegral_withDensity_eq_lintegral_mul‚ÇÄ]
  congr
  funext i
  simp only [Pi.mul_apply, MeasurableEquiv.apply_symm_apply]
  repeat fun_prop

lemma ŒºBolt_nsmul [SigmaFinite ùìí.Œº] (n : ‚Ñï) (T : Temperature) :
    (nsmul n ùìí).ŒºBolt T = MeasureTheory.Measure.pi fun _ => (ùìí.ŒºBolt T) := by
  induction n with
  | zero =>
    simp [nsmul, ŒºBolt]
    congr
    funext x
    exact Fin.elim0 x
  | succ n ih =>
    rw [nsmul_succ, ŒºBolt_congr]
    rw [ŒºBolt_add]
    refine MeasurePreserving.map_eq ?_
    refine MeasurePreserving.symm _ ?_
    rw [ih]
    exact MeasureTheory.measurePreserving_piFinSuccAbove (fun _ => ùìí.ŒºBolt T) 0

  lemma ŒºBolt_ne_zero_of_Œº_ne_zero (T : Temperature) (h : ùìí.Œº ‚â† 0) :
    ùìí.ŒºBolt T ‚â† 0 := by
  simp [ŒºBolt] at ‚ä¢ h
  rw [Measure.ext_iff'] at ‚ä¢ h
  simp only [Measure.coe_zero, Pi.zero_apply]
  have hs : {x | ENNReal.ofReal (rexp (-(‚ÜëT.Œ≤ * ùìí.energy x))) ‚â† 0} = Set.univ := by
    ext i
    simp only [ne_eq, ENNReal.ofReal_eq_zero, not_le, Set.mem_setOf_eq, Set.mem_univ, iff_true]
    exact exp_pos _
  conv =>
    enter [1, s]
    rw [MeasureTheory.withDensity_apply_eq_zero' (by fun_prop), hs]
    simp
  simpa using h

instance (T : Temperature) [NeZero ùìí.Œº] : NeZero (ùìí.ŒºBolt T) := by
  refine { out := ?_ }
  apply ŒºBolt_ne_zero_of_Œº_ne_zero
  exact Ne.symm (NeZero.ne' ùìí.Œº)

instance (T : Temperature) [IsFiniteMeasure (ùìí.ŒºBolt T)] [IsFiniteMeasure (ùìí1.ŒºBolt T)] :
    IsFiniteMeasure ((ùìí + ùìí1).ŒºBolt T) := by
  simp only [ŒºBolt_add]; infer_instance

instance (T : Temperature) [IsFiniteMeasure (ùìí.ŒºBolt T)] (n : ‚Ñï) :
    IsFiniteMeasure ((nsmul n ùìí).ŒºBolt T) := by
  simp [ŒºBolt_nsmul]; infer_instance

/-!

## The Mathematical Partition Function

-/

/-- The mathematical partition function, defined as the integral of the Boltzmann factor.
This quantity may have physical dimensions. See `CanonicalEnsemble.partitionFunction` for
the dimensionless physical version. -/
noncomputable def mathematicalPartitionFunction (T : Temperature) : ‚Ñù := (ùìí.ŒºBolt T).real Set.univ

lemma mathematicalPartitionFunction_eq_integral (T : Temperature) :
    mathematicalPartitionFunction ùìí T = ‚à´ i, exp (- T.Œ≤ * ùìí.energy i) ‚àÇùìí.Œº := by
  trans ‚à´ i, 1 ‚àÇùìí.ŒºBolt T
  ¬∑ simp only [integral_const, smul_eq_mul, mul_one]
    rfl
  rw [ŒºBolt]
  erw [integral_withDensity_eq_integral_smul]
  congr
  funext x
  simp [HSMul.hSMul, SMul.smul]
  ¬∑ exact exp_nonneg _
  ¬∑ fun_prop

lemma mathematicalPartitionFunction_add {T : Temperature} :
    (ùìí + ùìí1).mathematicalPartitionFunction T =
    ùìí.mathematicalPartitionFunction T * ùìí1.mathematicalPartitionFunction T := by
  simp_rw [mathematicalPartitionFunction, ŒºBolt_add]
  rw [‚Üê measureReal_prod_prod, Set.univ_prod_univ]

@[simp]
lemma mathematicalPartitionFunction_congr (e : Œπ1 ‚âÉ·µê Œπ) (T : Temperature) :
    (ùìí.congr e).mathematicalPartitionFunction T = ùìí.mathematicalPartitionFunction T := by
  rw [mathematicalPartitionFunction_eq_integral, mathematicalPartitionFunction_eq_integral]
  simp only [congr]
  rw [integral_map_equiv]
  simp

/-- The `mathematicalPartitionFunction_nsmul` function of `n` copies of a canonical ensemble. -/
lemma mathematicalPartitionFunction_nsmul (n : ‚Ñï) (T : Temperature) :
    (nsmul n ùìí).mathematicalPartitionFunction T = (ùìí.mathematicalPartitionFunction T) ^ n := by
  simp_rw [mathematicalPartitionFunction, ŒºBolt_nsmul, measureReal_def, Measure.pi_univ]
  simp [ENNReal.toReal_prod]

lemma mathematicalPartitionFunction_nonneg (T : Temperature) :
    0 ‚â§ ùìí.mathematicalPartitionFunction T := by
  rw [mathematicalPartitionFunction]; exact measureReal_nonneg

lemma mathematicalPartitionFunction_eq_zero_iff (T : Temperature) [IsFiniteMeasure (ùìí.ŒºBolt T)] :
    mathematicalPartitionFunction ùìí T = 0 ‚Üî ùìí.Œº = 0 := by
  simp [mathematicalPartitionFunction]
  rw [measureReal_def]
  rw [ENNReal.toReal_eq_zero_iff]
  simp only [measure_ne_top, or_false]
  rw [ŒºBolt]
  rw [MeasureTheory.withDensity_apply_eq_zero']
  simp only [neg_mul, ne_eq, ENNReal.ofReal_eq_zero, not_le, Set.inter_univ]
  let s : Set Œπ := {x | 0 < rexp (-(T.Œ≤ * ùìí.energy x))}
  have h : s = Set.univ := by
    ext i
    simp [s]
    exact exp_pos (-(T.Œ≤ * ùìí.energy i))
  change ùìí.Œº s = 0 ‚Üî ùìí.Œº = 0
  rw [h]
  simp only [Measure.measure_univ_eq_zero, s]
  fun_prop

open NNReal

lemma mathematicalPartitionFunction_comp_ofŒ≤_apply (Œ≤ : ‚Ñù‚â•0) :
    ùìí.mathematicalPartitionFunction (ofŒ≤ Œ≤) =
    (ùìí.Œº.withDensity (fun i => ENNReal.ofReal (exp (- Œ≤ * ùìí.energy i)))).real Set.univ := by
  simp only [mathematicalPartitionFunction, ŒºBolt, Œ≤_ofŒ≤, neg_mul]

/-- The partition function is strictly positive provided the underlying
measure is non-zero and the Boltzmann measure is finite. -/
lemma mathematicalPartitionFunction_pos (T : Temperature)
    [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº] :
    0 < ùìí.mathematicalPartitionFunction T := by
  simp [mathematicalPartitionFunction]

open NNReal Constants

/-! ## The probability density -/

/-- The probability density function of the canonical ensemble.
Note: In the general measure-theoretic case, this is a density with respect to the
underlying measure `ùìí.Œº` and is not necessarily less than or equal to 1. In the
case of a finite ensemble with the counting measure, this value corresponds to the
probability of the microstate. -/
noncomputable def probability (T : Temperature) (i : Œπ) : ‚Ñù :=
  (exp (- T.Œ≤ * ùìí.energy i)) / ùìí.mathematicalPartitionFunction T

/-! ## The probability measure -/

lemma probability_add {T : Temperature} (i : Œπ √ó Œπ1) :
    (ùìí + ùìí1).probability T i = ùìí.probability T i.1 * ùìí1.probability T i.2 := by
  simp [probability, mathematicalPartitionFunction_add, mul_add, Real.exp_add]
  ring

@[simp]
lemma probability_congr (e : Œπ1 ‚âÉ·µê Œπ) (T : Temperature) (i : Œπ1) :
    (ùìí.congr e).probability T i = ùìí.probability T (e i) := by
  simp [probability]

lemma probability_nsmul (n : ‚Ñï) (T : Temperature) (f : Fin n ‚Üí Œπ) :
    (nsmul n ùìí).probability T f = ‚àè i, ùìí.probability T (f i) := by
  induction n with
  | zero =>
    simp [probability, mathematicalPartitionFunction_nsmul]
  | succ n ih =>
    rw [nsmul_succ]
    rw [probability_congr]
    rw [probability_add]
    simp only [MeasurableEquiv.piFinSuccAbove_apply, Fin.insertNthEquiv_zero,
      Fin.consEquiv_symm_apply]
    rw [ih]
    exact Eq.symm (Fin.prod_univ_succAbove (fun i => ùìí.probability T (f i)) 0)

/-- The probability measure associated with the Boltzmann distribution of a
  canonical ensemble. -/
noncomputable def ŒºProd (T : Temperature) : MeasureTheory.Measure Œπ :=
  (ùìí.ŒºBolt T Set.univ)‚Åª¬π ‚Ä¢ ùìí.ŒºBolt T

instance (T : Temperature) : SigmaFinite (ùìí.ŒºProd T) :=
  inferInstanceAs (SigmaFinite ((ùìí.ŒºBolt T Set.univ)‚Åª¬π ‚Ä¢ ùìí.ŒºBolt T))

instance (T : Temperature) [IsFiniteMeasure (ùìí.ŒºBolt T)]
  [NeZero ùìí.Œº] : IsProbabilityMeasure (ùìí.ŒºProd T) := inferInstanceAs <|
  IsProbabilityMeasure ((ùìí.ŒºBolt T Set.univ)‚Åª¬π ‚Ä¢ ùìí.ŒºBolt T)

instance {T} : IsFiniteMeasure (ùìí.ŒºProd T) := by
  rw [ŒºProd]
  infer_instance

lemma ŒºProd_add {T : Temperature} [IsFiniteMeasure (ùìí.ŒºBolt T)]
    [IsFiniteMeasure (ùìí1.ŒºBolt T)] : (ùìí + ùìí1).ŒºProd T = (ùìí.ŒºProd T).prod (ùìí1.ŒºProd T) := by
  rw [ŒºProd, ŒºProd, ŒºProd, ŒºBolt_add]
  rw [MeasureTheory.Measure.prod_smul_left, MeasureTheory.Measure.prod_smul_right]
  rw [smul_smul]
  congr
  trans ((ùìí.ŒºBolt T) Set.univ * (ùìí1.ŒºBolt T) Set.univ)‚Åª¬π
  swap
  ¬∑ by_cases h : (ùìí.ŒºBolt T) Set.univ = 0
    ¬∑ simp [h]
    by_cases h1 : (ùìí1.ŒºBolt T) Set.univ = 0
    ¬∑ simp [h1]
    rw [ENNReal.mul_inv]
    ¬∑ simp
    ¬∑ simp
  ¬∑ rw [‚Üê @Measure.prod_prod]
    simp

lemma ŒºProd_congr (e : Œπ1 ‚âÉ·µê Œπ) (T : Temperature) :
    (ùìí.congr e).ŒºProd T = (ùìí.ŒºProd T).map e.symm := by
  simp [ŒºProd, ŒºBolt_congr]
  congr 2
  rw [MeasurableEquiv.map_apply]
  simp

lemma ŒºProd_nsmul (n : ‚Ñï) (T : Temperature) [IsFiniteMeasure (ùìí.ŒºBolt T)] :
    (nsmul n ùìí).ŒºProd T = MeasureTheory.Measure.pi fun _ => ùìí.ŒºProd T := by
  induction n with
  | zero =>
    simp [nsmul, ŒºProd, ŒºBolt]
    congr
    funext x
    exact Fin.elim0 x
  | succ n ih =>
    rw [nsmul_succ]
    rw [ŒºProd_congr]
    rw [ŒºProd_add]
    refine MeasurePreserving.map_eq ?_
    refine MeasurePreserving.symm _ ?_
    rw [ih]
    exact MeasureTheory.measurePreserving_piFinSuccAbove (fun _ => ùìí.ŒºProd T) 0

/-!

## Integrability of energy

-/

@[fun_prop]
lemma integrable_energy_add (T : Temperature) [IsFiniteMeasure (ùìí.ŒºBolt T)]
    [IsFiniteMeasure (ùìí1.ŒºBolt T)]
    (h : Integrable ùìí.energy (ùìí.ŒºProd T)) (h1 : Integrable ùìí1.energy (ùìí1.ŒºProd T)) :
    Integrable (ùìí + ùìí1).energy ((ùìí + ùìí1).ŒºProd T) := by
  rw [ŒºProd_add]
  refine Integrable.add'' ?_ ?_
  ¬∑ have h1 : (fun (i : Œπ √ó Œπ1) => ùìí.energy i.1)
      = fun (i : Œπ √ó Œπ1) => ùìí.energy i.1 * (fun (i : Œπ1) => 1) i.2 := by
      funext i
      simp
    rw [h1]
    apply Integrable.mul_prod (f := ùìí.energy) (g := (fun (i : Œπ1) => 1))
    ¬∑ fun_prop
    ¬∑ fun_prop
  ¬∑ have h1 : (fun (i : Œπ √ó Œπ1) => ùìí1.energy i.2)
      = fun (i : Œπ √ó Œπ1) => (fun (i : Œπ) => 1) i.1 * ùìí1.energy i.2 := by
      funext i
      simp
    rw [h1]
    apply Integrable.mul_prod (f := (fun (i : Œπ) => 1)) (g := ùìí1.energy)
    ¬∑ fun_prop
    ¬∑ fun_prop

@[fun_prop]
lemma integrable_energy_congr (T : Temperature) (e : Œπ1 ‚âÉ·µê Œπ)
    (h : Integrable ùìí.energy (ùìí.ŒºProd T)) :
    Integrable (ùìí.congr e).energy ((ùìí.congr e).ŒºProd T) := by
  simp [ŒºProd_congr]
  refine (integrable_map_equiv e.symm (ùìí.congr e).energy).mpr ?_
  simp only [congr_energy_comp_symmm]
  exact h

@[fun_prop]
lemma integrable_energy_nsmul (n : ‚Ñï) (T : Temperature)
    [IsFiniteMeasure (ùìí.ŒºBolt T)]
    (h : Integrable ùìí.energy (ùìí.ŒºProd T)) :
    Integrable (nsmul n ùìí).energy ((nsmul n ùìí).ŒºProd T) := by
  induction n with
  | zero =>
    simp [nsmul, ŒºProd_nsmul]
  | succ n ih =>
    rw [nsmul_succ]
    apply integrable_energy_congr
    apply integrable_energy_add
    ¬∑ exact h
    ¬∑ exact ih

/-!

## The mean energy

-/

/-- The mean energy of the canonical ensemble at temperature `T`. -/
noncomputable def meanEnergy (T : Temperature) : ‚Ñù := ‚à´ i, ùìí.energy i ‚àÇùìí.ŒºProd T

lemma meanEnergy_add {T : Temperature}
    [IsFiniteMeasure (ùìí1.ŒºBolt T)] [IsFiniteMeasure (ùìí.ŒºBolt T)]
    [NeZero ùìí.Œº] [NeZero ùìí1.Œº]
    (h1 : Integrable ùìí.energy (ùìí.ŒºProd T))
    (h2 : Integrable ùìí1.energy (ùìí1.ŒºProd T)) :
    (ùìí + ùìí1).meanEnergy T = ùìí.meanEnergy T + ùìí1.meanEnergy T := by
  rw [meanEnergy]
  simp only [energy_add_apply]
  rw [ŒºProd_add]
  rw [MeasureTheory.integral_prod]
  simp only
  conv_lhs =>
    enter [2, x]
    rw [integral_add (integrable_const _) h2]
    rw [integral_const]
    simp
  rw [integral_add h1 (integrable_const _)]
  rw [integral_const]
  simp
  rfl
  ¬∑ simpa [ŒºProd_add] using integrable_energy_add ùìí ùìí1 T h1 h2

lemma meanEnergy_congr (e : Œπ1 ‚âÉ·µê Œπ) (T : Temperature) :
    (ùìí.congr e).meanEnergy T = ùìí.meanEnergy T := by
  simp [meanEnergy, ŒºProd_congr]
  refine MeasurePreserving.integral_comp' ?_ ùìí.energy
  refine { measurable := ?_, map_eq := ?_ }
  ¬∑ exact MeasurableEquiv.measurable e
  ¬∑ exact MeasurableEquiv.map_map_symm e

lemma meanEnergy_nsmul (n : ‚Ñï) (T : Temperature)
    [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº]
    (h1 : Integrable ùìí.energy (ùìí.ŒºProd T)) :
    (nsmul n ùìí).meanEnergy T = n * ùìí.meanEnergy T := by
  induction n with
  | zero =>
    simp [nsmul, meanEnergy, ŒºProd_nsmul]
  | succ n ih =>
    rw [nsmul_succ, meanEnergy_congr, meanEnergy_add, ih]
    simp only [Nat.cast_add, Nat.cast_one]
    ring
    ¬∑ exact h1
    ¬∑ exact integrable_energy_nsmul ùìí n T h1

/-!

## The differential entropy

-/

/-- The (differential) entropy of the canonical ensemble. In the continuous case, this quantity
is not absolute but depends on the choice of units for the measure. It can be negative.
See `thermodynamicEntropy` for the absolute physical quantity. -/
noncomputable def differentialEntropy (T : Temperature) : ‚Ñù :=
  - kB * ‚à´ i, log (probability ùìí T i) ‚àÇùìí.ŒºProd T

/-- Probabilities are non-negative,
assuming a positive partition function. -/
lemma probability_nonneg
    (T : Temperature) [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº] (i : Œπ) :
    0 ‚â§ ùìí.probability T i := by
  -- Use positivity of the (mathematical) partition function (already defined above)
  have hpos := mathematicalPartitionFunction_pos (ùìí:=ùìí) (T:=T)
  simp [CanonicalEnsemble.probability, div_nonneg, Real.exp_nonneg, hpos.le]

/-- Probabilities are strictly positive. -/
lemma probability_pos
    (T : Temperature) [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº] (i : Œπ) :
    0 < ùìí.probability T i := by
  have hZpos := mathematicalPartitionFunction_pos (ùìí:=ùìí) (T:=T)
  simp [probability, div_pos, Real.exp_pos, hZpos]

/-- General entropy non-negativity under a pointwise upper bound `probability ‚â§ 1`.
This assumption holds automatically in the finite/counting case (since sums bound each term),
but can fail in general (continuous) settings; hence we separate it as a hypothesis.
Finite case: see `CanonicalEnsemble.entropy_nonneg` in `Finite`. -/
lemma differentialEntropy_nonneg_of_prob_le_one
    (T : Temperature) [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº]
    (hInt : Integrable (fun i => Real.log (ùìí.probability T i)) (ùìí.ŒºProd T))
    (hP_le_one : ‚àÄ i, ùìí.probability T i ‚â§ 1) :
    0 ‚â§ ùìí.differentialEntropy T := by
  have hPoint :
      (fun i => Real.log (ùìí.probability T i)) ‚â§·µê[ùìí.ŒºProd T] fun _ => 0 := by
    refine Filter.Eventually.of_forall ?_
    intro i
    have hpos := probability_pos (ùìí:=ùìí) (T:=T) i
    have hle  := hP_le_one i
    have hle' : ùìí.probability T i ‚â§ Real.exp 0 := by
      simpa [Real.exp_zero] using hle
    exact (log_le_iff_le_exp hpos).mpr hle'
  have hInt0 : Integrable (fun _ : Œπ => (0 : ‚Ñù)) (ùìí.ŒºProd T) := integrable_const _
  have hIntLe : (‚à´ i, Real.log (ùìí.probability T i) ‚àÇùìí.ŒºProd T)
      ‚â§ (‚à´ _i, (0 : ‚Ñù) ‚àÇùìí.ŒºProd T) :=
    integral_mono_ae hInt hInt0 hPoint
  have hent :
      ùìí.differentialEntropy T
        = - kB * (‚à´ i, Real.log (ùìí.probability T i) ‚àÇùìí.ŒºProd T) := rfl
  have hkB : 0 ‚â§ kB := kB_nonneg
  have hIle0 : (‚à´ i, Real.log (ùìí.probability T i) ‚àÇùìí.ŒºProd T) ‚â§ 0 := by
    simpa [integral_const] using hIntLe
  have hProd :
      0 ‚â§ - kB * (‚à´ i, Real.log (ùìí.probability T i) ‚àÇùìí.ŒºProd T) :=
    mul_nonneg_of_nonpos_of_nonpos (neg_nonpos.mpr hkB) hIle0
  simpa [hent] using hProd

/-!

## Thermodynamic Quantities

These are the dimensionless physical quantities derived from the mathematical definitions
by incorporating the phase space volume `ùìí.phase_space_unit ^ ùìí.dof`.
-/

open Constants

/-- The dimensionless thermodynamic partition function, `Z = Z_math / h^dof`. -/
noncomputable def partitionFunction (T : Temperature) : ‚Ñù :=
  ùìí.mathematicalPartitionFunction T / (ùìí.phase_space_unit ^ ùìí.dof)

@[simp] lemma partitionFunction_def (ùìí : CanonicalEnsemble Œπ) (T : Temperature) :
    ùìí.partitionFunction T
      = ùìí.mathematicalPartitionFunction T / (ùìí.phase_space_unit ^ ùìí.dof) := rfl

lemma partitionFunction_pos
    (ùìí : CanonicalEnsemble Œπ) (T : Temperature)
    [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº] :
    0 < ùìí.partitionFunction T := by
  have hZ := ùìí.mathematicalPartitionFunction_pos T
  have hden : 0 < ùìí.phase_space_unit ^ ùìí.dof := pow_pos ùìí.h_pos _
  simp [partitionFunction, hZ, hden]

lemma partitionFunction_congr
    (ùìí : CanonicalEnsemble Œπ) (e : Œπ1 ‚âÉ·µê Œπ) (T : Temperature) :
    (ùìí.congr e).partitionFunction T = ùìí.partitionFunction T := by
  simp [partitionFunction]

lemma partitionFunction_add
    (ùìí : CanonicalEnsemble Œπ) (ùìí1 : CanonicalEnsemble Œπ1)
    (T : Temperature)
    [IsFiniteMeasure (ùìí.ŒºBolt T)] [IsFiniteMeasure (ùìí1.ŒºBolt T)]
    (h : ùìí.phase_space_unit = ùìí1.phase_space_unit) :
    (ùìí + ùìí1).partitionFunction T
      = ùìí.partitionFunction T * ùìí1.partitionFunction T := by
  have hpow :
      ùìí.phase_space_unit ^ (ùìí.dof + ùìí1.dof)
        = (ùìí.phase_space_unit ^ ùìí.dof) * (ùìí.phase_space_unit ^ ùìí1.dof) := by
    simp [pow_add, mul_comm, mul_left_comm, mul_assoc]
  have hsplit :
    (ùìí.mathematicalPartitionFunction T * ùìí1.mathematicalPartitionFunction T) /
        ((ùìí.phase_space_unit ^ ùìí.dof) * (ùìí.phase_space_unit ^ ùìí1.dof))
      =
      (ùìí.mathematicalPartitionFunction T / ùìí.phase_space_unit ^ ùìí.dof) *
        (ùìí1.mathematicalPartitionFunction T / ùìí.phase_space_unit ^ ùìí1.dof) := by
    simp [div_eq_mul_inv, mul_comm, mul_left_comm, mul_assoc]
  simp [partitionFunction, mathematicalPartitionFunction_add, hpow, hsplit, h,
        mul_comm, mul_left_comm, mul_assoc]
  ring_nf

lemma partitionFunction_nsmul
    (ùìí : CanonicalEnsemble Œπ) (n : ‚Ñï) (T : Temperature)
    [IsFiniteMeasure (ùìí.ŒºBolt T)] :
    (nsmul n ùìí).partitionFunction T
      = (ùìí.partitionFunction T) ^ n := by
  simp [partitionFunction, mathematicalPartitionFunction_nsmul,
        dof_nsmul, phase_space_unit_nsmul, pow_mul, mul_comm, mul_left_comm, mul_assoc]
  ring_nf

@[simp]
lemma partitionFunction_dof_zero
  (ùìí : CanonicalEnsemble Œπ) (T : Temperature) (h : ùìí.dof = 0) :
  ùìí.partitionFunction T = ùìí.mathematicalPartitionFunction T := by
simp [partitionFunction, h]

@[simp]
lemma partitionFunction_phase_space_unit_one
  (ùìí : CanonicalEnsemble Œπ) (T : Temperature) (h : ùìí.phase_space_unit = 1) :
  ùìí.partitionFunction T = ùìí.mathematicalPartitionFunction T := by
simp [partitionFunction, h]

lemma log_partitionFunction
    (ùìí : CanonicalEnsemble Œπ) (T : Temperature)
    [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº] :
    Real.log (ùìí.partitionFunction T)
      = Real.log (ùìí.mathematicalPartitionFunction T)
        - (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit := by
  have hZ := ùìí.mathematicalPartitionFunction_pos T
  have hden : 0 < ùìí.phase_space_unit ^ ùìí.dof := pow_pos ùìí.h_pos _
  have hlogpow :
      Real.log (ùìí.phase_space_unit ^ ùìí.dof)
        = (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit := by
    simp
  simp [partitionFunction, Real.log_div hZ.ne' hden.ne', hlogpow,
        sub_eq_add_neg, mul_comm, mul_left_comm, mul_assoc]

/-- The Helmholtz free energy, `F = -k_B T log(Z)`. This is the central
quantity from which other thermodynamic properties are derived. -/
noncomputable def helmholtzFreeEnergy (T : Temperature) : ‚Ñù :=
  - kB * T.val * Real.log (ùìí.partitionFunction T)

@[simp]
lemma helmholtzFreeEnergy_def
  (ùìí : CanonicalEnsemble Œπ) (T : Temperature) :
  ùìí.helmholtzFreeEnergy T
    = - kB * T.val * Real.log (ùìí.partitionFunction T) := rfl

lemma helmholtzFreeEnergy_congr
    (ùìí : CanonicalEnsemble Œπ) (e : Œπ1 ‚âÉ·µê Œπ) (T : Temperature) :
    (ùìí.congr e).helmholtzFreeEnergy T = ùìí.helmholtzFreeEnergy T := by
  simp [helmholtzFreeEnergy, partitionFunction_congr]

@[simp] lemma helmholtzFreeEnergy_dof_zero
    (ùìí : CanonicalEnsemble Œπ) (T : Temperature) (h : ùìí.dof = 0) :
    ùìí.helmholtzFreeEnergy T
      = -kB * T.val * Real.log (ùìí.mathematicalPartitionFunction T) := by
  simp [helmholtzFreeEnergy, partitionFunction, h]

@[simp] lemma helmholtzFreeEnergy_phase_space_unit_one
    (ùìí : CanonicalEnsemble Œπ) (T : Temperature) (h : ùìí.phase_space_unit = 1) :
    ùìí.helmholtzFreeEnergy T
      = -kB * T.val * Real.log (ùìí.mathematicalPartitionFunction T) := by
  simp [helmholtzFreeEnergy, partitionFunction, h]

lemma helmholtzFreeEnergy_add
    (ùìí : CanonicalEnsemble Œπ) (ùìí1 : CanonicalEnsemble Œπ1) (T : Temperature)
    [IsFiniteMeasure (ùìí.ŒºBolt T)] [IsFiniteMeasure (ùìí1.ŒºBolt T)]
    [NeZero ùìí.Œº] [NeZero ùìí1.Œº]
    (h : ùìí.phase_space_unit = ùìí1.phase_space_unit) :
    (ùìí + ùìí1).helmholtzFreeEnergy T
      = ùìí.helmholtzFreeEnergy T + ùìí1.helmholtzFreeEnergy T := by
  have hPF := partitionFunction_add (ùìí:=ùìí) (ùìí1:=ùìí1) (T:=T) h
  have hpf‚ÇÅ : 0 < ùìí.partitionFunction T  := partitionFunction_pos (ùìí:=ùìí)  (T:=T)
  have hpf‚ÇÇ : 0 < ùìí1.partitionFunction T := partitionFunction_pos (ùìí:=ùìí1) (T:=T)
  calc
    (ùìí + ùìí1).helmholtzFreeEnergy T
        = -kB * T.val * Real.log ((ùìí + ùìí1).partitionFunction T) := rfl
    _ = -kB * T.val * Real.log (ùìí.partitionFunction T * ùìí1.partitionFunction T) := by
          rw [hPF]
    _ = -kB * T.val *
          (Real.log (ùìí.partitionFunction T) + Real.log (ùìí1.partitionFunction T)) := by
          rw [Real.log_mul hpf‚ÇÅ.ne' hpf‚ÇÇ.ne']
    _ = (-kB * T.val) * Real.log (ùìí.partitionFunction T)
        + (-kB * T.val) * Real.log (ùìí1.partitionFunction T) := by
          ring
    _ = ùìí.helmholtzFreeEnergy T + ùìí1.helmholtzFreeEnergy T := by
          simp [helmholtzFreeEnergy, mul_comm, mul_left_comm, mul_assoc]

lemma helmholtzFreeEnergy_nsmul
    (ùìí : CanonicalEnsemble Œπ) (n : ‚Ñï) (T : Temperature)
    [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº] :
    (nsmul n ùìí).helmholtzFreeEnergy T
      = n * ùìí.helmholtzFreeEnergy T := by
  have hPF := partitionFunction_nsmul (ùìí:=ùìí) (n:=n) (T:=T)
  have hpos : 0 < ùìí.partitionFunction T := partitionFunction_pos (ùìí:=ùìí) (T:=T)
  have hlogpow :
      Real.log ((ùìí.partitionFunction T) ^ n)
        = (n : ‚Ñù) * Real.log (ùìí.partitionFunction T) := by
    induction n with
    | zero => simp
    | succ n ih =>
        have hz : ùìí.partitionFunction T ‚â† 0 := hpos.ne'
        have hzPow : (ùìí.partitionFunction T) ^ n ‚â† 0 := pow_ne_zero _ hz
        rw [log_pow]
  have hlog :
      Real.log ((nsmul n ùìí).partitionFunction T)
        = (n : ‚Ñù) * Real.log (ùìí.partitionFunction T) := by
    rw [hPF]
    simp
  calc
    (nsmul n ùìí).helmholtzFreeEnergy T
        = -kB * T.val * Real.log ((nsmul n ùìí).partitionFunction T) := rfl
    _ = -kB * T.val * ((n : ‚Ñù) * Real.log (ùìí.partitionFunction T)) := by
          rw [hlog]
    _ = (n : ‚Ñù) * (-kB * T.val * Real.log (ùìí.partitionFunction T)) := by
          ring
    _ = n * ùìí.helmholtzFreeEnergy T := by
          simp [helmholtzFreeEnergy, mul_comm, mul_left_comm, mul_assoc]

/-- The dimensionless physical probability density. This is obtained by dividing the
phase space measure by the fundamental unit `h^dof`, making the probability
density `œÅ_phys = œÅ_math * h^dof` dimensionless. -/
noncomputable def physicalProbability (T : Temperature) (i : Œπ) : ‚Ñù :=
  ùìí.probability T i * (ùìí.phase_space_unit ^ ùìí.dof)

@[simp] lemma physicalProbability_def (T : Temperature) (i : Œπ) :
    ùìí.physicalProbability T i
      = ùìí.probability T i * (ùìí.phase_space_unit ^ ùìí.dof) := rfl

lemma physicalProbability_measurable (T : Temperature)
    [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº] :
    Measurable (ùìí.physicalProbability T) := by
  let c : ‚Ñù := (ùìí.phase_space_unit ^ ùìí.dof) / ùìí.mathematicalPartitionFunction T
  have h_energy_meas : Measurable fun i => ùìí.energy i := ùìí.energy_measurable
  have h_mul_meas : Measurable fun i => (-(T.Œ≤ : ‚Ñù)) * ùìí.energy i := by
    simpa [mul_comm] using h_energy_meas.const_mul (-(T.Œ≤ : ‚Ñù))
  have h_exp_meas : Measurable fun i => Real.exp (-(T.Œ≤ : ‚Ñù) * ùìí.energy i) :=
    (continuous_exp.measurable.comp h_mul_meas)
  have h_fun_meas : Measurable fun i => c * Real.exp (-(T.Œ≤ : ‚Ñù) * ùìí.energy i) := by
    simpa [mul_comm] using (h_exp_meas.const_mul c)
  have h_eq :
      (fun i => ùìí.physicalProbability T i)
        = fun i => c * Real.exp (-(T.Œ≤ : ‚Ñù) * ùìí.energy i) := by
    funext i
    simp [physicalProbability, probability, c, div_eq_mul_inv,
          mul_comm, mul_left_comm, mul_assoc]
  simpa [h_eq] using h_fun_meas

lemma physicalProbability_nonneg
    (T : Temperature) [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº] (i : Œπ) :
    0 ‚â§ ùìí.physicalProbability T i := by
  have hp := ùìí.probability_nonneg (T:=T) i
  exact mul_nonneg hp (by exact pow_nonneg (le_of_lt ùìí.h_pos) _)

lemma physicalProbability_pos
    (T : Temperature) [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº] (i : Œπ) :
    0 < ùìí.physicalProbability T i := by
  have hp := ùìí.probability_pos (T:=T) i
  exact mul_pos hp (pow_pos ùìí.h_pos _)

lemma log_physicalProbability
    (T : Temperature) [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº] (i : Œπ) :
    Real.log (ùìí.physicalProbability T i)
      = Real.log (ùìí.probability T i) + (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit := by
  have hppos := ùìí.physicalProbability_pos (T:=T) i
  have hppos' := ùìí.probability_pos (T:=T) i
  have hpowpos : 0 < ùìí.phase_space_unit ^ ùìí.dof := pow_pos ùìí.h_pos _
  simp [physicalProbability, Real.log_mul hppos'.ne' hpowpos.ne', Real.log_pow, Nat.cast_id]

lemma integral_probability
    (ùìí : CanonicalEnsemble Œπ) (T : Temperature)
    [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº] :
    (‚à´ i, ùìí.probability T i ‚àÇ ùìí.Œº) = 1 := by
  classical
  have hZ :
      ùìí.mathematicalPartitionFunction T
        = ‚à´ i, Real.exp (- T.Œ≤ * ùìí.energy i) ‚àÇ ùìí.Œº :=
    mathematicalPartitionFunction_eq_integral (ùìí:=ùìí) (T:=T)
  have hZpos : 0 < ùìí.mathematicalPartitionFunction T :=
    ùìí.mathematicalPartitionFunction_pos T
  have h_int :
      (‚à´ i, ùìí.probability T i ‚àÇ ùìí.Œº)
        = (ùìí.mathematicalPartitionFunction T)‚Åª¬π *
          (‚à´ i, Real.exp (- T.Œ≤ * ùìí.energy i) ‚àÇ ùìí.Œº) := by
    simp [probability, div_eq_mul_inv, integral_const_mul,
          mul_comm, mul_left_comm, mul_assoc]
  calc
    (‚à´ i, ùìí.probability T i ‚àÇ ùìí.Œº)
        = (ùìí.mathematicalPartitionFunction T)‚Åª¬π *
          (‚à´ i, Real.exp (- T.Œ≤ * ùìí.energy i) ‚àÇ ùìí.Œº) := h_int
    _ = (ùìí.mathematicalPartitionFunction T)‚Åª¬π *
          ùìí.mathematicalPartitionFunction T := by simp [hZ]
    _ = 1 := by simp [hZpos.ne']

/-- Normalization of the dimensionless physical probability density over the base measure. -/
lemma integral_physicalProbability_base
    (ùìí : CanonicalEnsemble Œπ) (T : Temperature)
    [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº] :
    (‚à´ i, ùìí.physicalProbability T i ‚àÇ ùìí.Œº)
      = ùìí.phase_space_unit ^ ùìí.dof := by
  classical
  have hnorm := integral_probability (ùìí:=ùìí) (T:=T)
  calc
    (‚à´ i, ùìí.physicalProbability T i ‚àÇ ùìí.Œº)
        = (‚à´ i, ùìí.probability T i * (ùìí.phase_space_unit ^ ùìí.dof) ‚àÇ ùìí.Œº) := by
              simp [physicalProbability, mul_comm, mul_left_comm, mul_assoc]
    _ = (‚à´ i, ùìí.probability T i ‚àÇ ùìí.Œº) * (ùìí.phase_space_unit ^ ùìí.dof) := by
              simp [physicalProbability, integral_mul_const,
                    mul_comm, mul_left_comm, mul_assoc]
    _ = 1 * (ùìí.phase_space_unit ^ ùìí.dof) := by simp [hnorm]
    _ = ùìí.phase_space_unit ^ ùìí.dof := by ring

@[simp] lemma physicalProbability_dof_zero
    (T : Temperature) (h : ùìí.dof = 0) (i : Œπ) :
    ùìí.physicalProbability T i = ùìí.probability T i := by
  simp [physicalProbability, h]

@[simp] lemma physicalProbability_phase_space_unit_one
    (T : Temperature) (h : ùìí.phase_space_unit = 1) (i : Œπ) :
    ùìí.physicalProbability T i = ùìí.probability T i := by
  simp [physicalProbability, h]

lemma physicalProbability_congr (e : Œπ1 ‚âÉ·µê Œπ) (T : Temperature) (i : Œπ1) :
    (ùìí.congr e).physicalProbability T i
      = ùìí.physicalProbability T (e i) := by
  simp [physicalProbability, probability]

lemma physicalProbability_add
    {Œπ1} [MeasurableSpace Œπ1]
    (ùìí1 : CanonicalEnsemble Œπ1) (T : Temperature) (i : Œπ √ó Œπ1)
    (h : ùìí.phase_space_unit = ùìí1.phase_space_unit) :
    (ùìí + ùìí1).physicalProbability T i
      = ùìí.physicalProbability T i.1 * ùìí1.physicalProbability T i.2 := by
  simp [physicalProbability, probability_add, phase_space_unit_add, dof_add, h, pow_add]
  ring

/-- The absolute thermodynamic entropy, defined from its statistical mechanical foundation as
the Gibbs-Shannon entropy of the dimensionless physical probability distribution.
This corresponds to Landau & Lifshitz, Statistical Physics, ¬ß7, Eq. 7.12. -/
noncomputable def thermodynamicEntropy (T : Temperature) : ‚Ñù :=
  -kB * ‚à´ i, Real.log (ùìí.physicalProbability T i) ‚àÇ(ùìí.ŒºProd T)

@[simp]
lemma thermodynamicEntropy_def (T : Temperature) :
  ùìí.thermodynamicEntropy T
    = -kB * ‚à´ i, Real.log (ùìí.physicalProbability T i) ‚àÇ ùìí.ŒºProd T := rfl

/-!

## Relations between Mathematical and Thermodynamic Quantities

-/

/-- An intermediate potential defined from the mathematical partition function. See
`helmholtzFreeEnergy` for the physical thermodynamic quantity. -/
noncomputable def mathematicalHelmholtzFreeEnergy (T : Temperature) : ‚Ñù :=
  - kB * T.val * Real.log (ùìí.mathematicalPartitionFunction T)

/-- The relationship between the physical Helmholtz Free Energy and the Helmholtz Potential. -/
lemma helmholtzFreeEnergy_eq_helmholtzMathematicalFreeEnergy_add_correction (T : Temperature)
    [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº] :
    ùìí.helmholtzFreeEnergy T = ùìí.mathematicalHelmholtzFreeEnergy T +
      kB * T.val * ùìí.dof * Real.log (ùìí.phase_space_unit) := by
  have hZ_pos := mathematicalPartitionFunction_pos ùìí T
  have h_pow_pos : 0 < ùìí.phase_space_unit ^ ùìí.dof := pow_pos ùìí.h_pos _
  simp_rw [helmholtzFreeEnergy, mathematicalHelmholtzFreeEnergy, partitionFunction,
    Real.log_div hZ_pos.ne' h_pow_pos.ne']
  have h_log_pow : Real.log (ùìí.phase_space_unit ^ ùìí.dof)
      = (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit := by
    simp
  simp [sub_eq_add_neg, h_log_pow, mul_add, add_comm, add_left_comm, add_assoc,
        mul_comm, mul_left_comm, mul_assoc]

/-- General identity: S_diff = kB Œ≤ ‚ü®E‚ü© + kB log Z_math.
This connects the differential entropy to the mean energy and the mathematical partition function.
Integrability of `log (probability ‚Ä¶)` follows from the pointwise formula. -/
lemma differentialEntropy_eq_kB_beta_meanEnergy_add_kB_log_mathZ
    (T : Temperature) [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº]
    (hE : Integrable ùìí.energy (ùìí.ŒºProd T)) :
    ùìí.differentialEntropy T = kB * (T.Œ≤ : ‚Ñù) * ùìí.meanEnergy T +
      kB * Real.log (ùìí.mathematicalPartitionFunction T) := by
  set Z := ùìí.mathematicalPartitionFunction T
  have hZpos := mathematicalPartitionFunction_pos ùìí T
  have h_log_prob : ‚àÄ i, Real.log (ùìí.probability T i) =
      - (T.Œ≤ : ‚Ñù) * ùìí.energy i - Real.log Z := by
    intro i
    have : 0 < Z := hZpos
    rw [probability, Real.log_div (exp_pos _).ne' this.ne', Real.log_exp]
  unfold differentialEntropy
  rw [integral_congr_ae (ae_of_all _ h_log_prob)]
  have h_split :
      (fun i => - (T.Œ≤ : ‚Ñù) * ùìí.energy i - Real.log Z)
        = (fun i => (- (T.Œ≤ : ‚Ñù)) * ùìí.energy i + (- Real.log Z)) := by
    funext i; ring
  simp_rw [h_split]
  have h_int1 : Integrable (fun _ : Œπ => - Real.log Z) (ùìí.ŒºProd T) :=
    (integrable_const _)
  have h_intE : Integrable (fun i => (- (T.Œ≤ : ‚Ñù)) * ùìí.energy i) (ùìí.ŒºProd T) :=
    (hE.const_mul _)
  rw [integral_add h_intE h_int1,
      integral_const_mul, meanEnergy, integral_const]
  simp [mul_add, add_comm, add_left_comm, add_assoc, sub_eq_add_neg,
        mul_comm, mul_left_comm, mul_assoc, differentialEntropy, probability,
       mul_comm, mul_left_comm, mul_assoc]

/-- Pointwise logarithm of the Boltzmann probability. -/
lemma log_probability
    (ùìí : CanonicalEnsemble Œπ) (T : Temperature)
    [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº] (i : Œπ) :
    Real.log (ùìí.probability T i)
      = - (Œ≤ T) * ùìí.energy i - Real.log (ùìí.mathematicalPartitionFunction T) := by
  have hZpos := mathematicalPartitionFunction_pos (ùìí:=ùìí) (T:=T)
  unfold probability
  simp [Real.log_div, hZpos.ne', Real.log_exp, sub_eq_add_neg]

/--  Auxiliary identity: `kB ¬∑ Œ≤ = 1 / T`.
`Œ≤` is defined as `1 / (kB ¬∑ T)` (see `Temperature.Œ≤`).
The proof just clears denominators with `field_simp`. -/
@[simp]
private lemma kB_mul_beta (T : Temperature) (hT : 0 < T.val) :
    (kB : ‚Ñù) * (T.Œ≤ : ‚Ñù) = 1 / T.val := by
  have hkB : (kB : ‚Ñù) ‚â† 0 := kB_neq_zero
  have hT0 : (T.val : ‚Ñù) ‚â† 0 := by
    exact_mod_cast (ne_of_gt hT)
  field_simp [Temperature.Œ≤, hkB, hT0]
  rw [mul_div_mul_left (‚ÜëT.val) T.toReal hkB]
  erw [propext (div_eq_one_iff_eq hT0)]

set_option linter.unusedVariables false in
/-- Fundamental relation between thermodynamic and differential entropy:
`S_thermo = S_diff - kB * dof * log h`. -/
lemma thermodynamicEntropy_eq_differentialEntropy_sub_correction
    (T : Temperature) (hT : 0 < T.val)
    (hE : Integrable ùìí.energy (ùìí.ŒºProd T))
    [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº] :
    ùìí.thermodynamicEntropy T
      = ùìí.differentialEntropy T
        - kB * ùìí.dof * Real.log ùìí.phase_space_unit := by
  classical
  have h_log_phys_pt :
      ‚àÄ i, Real.log (ùìí.physicalProbability T i)
        = Real.log (ùìí.probability T i)
            + (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit := by
    intro i; simpa using ùìí.log_physicalProbability (T:=T) i
  have hZpos := ùìí.mathematicalPartitionFunction_pos (T:=T)
  have h_log_prob_point :
      ‚àÄ i, Real.log (ùìí.probability T i)
        = (- (T.Œ≤ : ‚Ñù)) * ùìí.energy i
            - Real.log (ùìí.mathematicalPartitionFunction T) := by
    intro i
    have : 0 < ùìí.probability T i := ùìí.probability_pos (T:=T) i
    have hden := hZpos
    simp [CanonicalEnsemble.probability, Real.log_div, hden.ne', Real.log_exp,
          sub_eq_add_neg, mul_comm, mul_left_comm, mul_assoc]
  have h_log_prob_split :
      (fun i => Real.log (ùìí.probability T i))
        =
      (fun i =>
        (- (T.Œ≤ : ‚Ñù)) * ùìí.energy i
          + (- Real.log (ùìí.mathematicalPartitionFunction T))) := by
    funext i
    simp [h_log_prob_point i, sub_eq_add_neg, add_comm, add_left_comm, add_assoc]
  have h_int_log_prob :
      Integrable (fun i => Real.log (ùìí.probability T i)) (ùìí.ŒºProd T) := by
    have h_intE :
        Integrable (fun i => (- (T.Œ≤ : ‚Ñù)) * ùìí.energy i) (ùìí.ŒºProd T) :=
      hE.const_mul _
    have h_intC :
        Integrable (fun _ : Œπ => - Real.log (ùìí.mathematicalPartitionFunction T))
          (ùìí.ŒºProd T) := integrable_const _
    simpa [h_log_prob_split] using h_intE.add h_intC
  have h_int_const :
      Integrable (fun _ : Œπ =>
          (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit) (ùìí.ŒºProd T) :=
    integrable_const _
  have h_int_log_phys :
      Integrable (fun i => Real.log (ùìí.physicalProbability T i)) (ùìí.ŒºProd T) := by
    have h_sum := h_int_log_prob.add h_int_const
    have h_eq :
        (fun i => Real.log (ùìí.physicalProbability T i))
          =
        (fun i =>
          Real.log (ùìí.probability T i)
            + (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit) := by
      funext i; exact h_log_phys_pt i
    simp_all only [physicalProbability_def, neg_mul, enorm_neg, ne_eq, enorm_ne_top,
      not_false_eq_true, integrable_const_enorm, integrable_add_iff_integrable_left',
      integrable_add_iff_integrable_right', integrable_add_iff_integrable_right]
  have h_int_rewrite :
      ‚à´ i, Real.log (ùìí.physicalProbability T i) ‚àÇ ùìí.ŒºProd T
        =
      ‚à´ i, (Real.log (ùìí.probability T i)
              + (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit) ‚àÇ ùìí.ŒºProd T := by
    have h_eq :
        (fun i => Real.log (ùìí.physicalProbability T i))
          =
        (fun i =>
          Real.log (ùìí.probability T i)
            + (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit) := by
      funext i; exact h_log_phys_pt i
    simp [h_eq]
    ring_nf
    simp_all only [physicalProbability_def, neg_mul, enorm_neg, ne_eq, enorm_ne_top,
      not_false_eq_true, integrable_const_enorm, integrable_add_iff_integrable_left',
      integrable_add_iff_integrable_right']
  unfold thermodynamicEntropy differentialEntropy
  rw    [h_int_rewrite,
    integral_add h_int_log_prob h_int_const,
    integral_const, add_comm,
    mul_add, sub_eq_add_neg, mul_comm, mul_assoc]
  ring_nf
  simp_all only [physicalProbability_def, neg_mul, enorm_neg, ne_eq, enorm_ne_top,
    not_false_eq_true, integrable_const_enorm, integrable_add_iff_integrable_left',
    integrable_add_iff_integrable_right', measureReal_univ_eq_one, smul_eq_mul, one_mul]

/-- No semiclassical correction when `dof = 0`. -/
lemma thermodynamicEntropy_eq_differentialEntropy_of_dof_zero
    (T : Temperature) (hT : 0 < T.val) (hE : Integrable ùìí.energy (ùìí.ŒºProd T))
    (h0 : ùìí.dof = 0)
    [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº] :
    ùìí.thermodynamicEntropy T = ùìí.differentialEntropy T := by
  have h' :=
    ùìí.thermodynamicEntropy_eq_differentialEntropy_sub_correction
      (T:=T) hT (hE:=hE)
  have : (kB : ‚Ñù) * (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit = 0 := by
    simp [h0]
  simp_all only [thermodynamicEntropy_def, physicalProbability_def, pow_zero, mul_one, neg_mul,
    CharP.cast_eq_zero, mul_zero, zero_mul, sub_zero]

/-- No semiclassical correction when `phase_space_unit = 1`. -/
lemma thermodynamicEntropy_eq_differentialEntropy_of_phase_space_unit_one
    (T : Temperature) (hT : 0 < T.val) (hE : Integrable ùìí.energy (ùìí.ŒºProd T))
    (h1 : ùìí.phase_space_unit = 1)
    [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº] :
    ùìí.thermodynamicEntropy T = ùìí.differentialEntropy T := by
  have h' :=
    ùìí.thermodynamicEntropy_eq_differentialEntropy_sub_correction
      (T:=T) hT (hE:=hE)
  have : Real.log ùìí.phase_space_unit = 0 := by simp [h1]
  have hcorr :
      (kB : ‚Ñù) * (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit = 0 := by
    simp [this]
  simp_all only [thermodynamicEntropy_def, physicalProbability_def, one_pow, mul_one, neg_mul,
    log_one, mul_zero, sub_zero]
/-

## Thermodynamic Identities

-/

/-!

## The Fundamental Thermodynamic Identity

-/

/-- The Helmholtz free energy `F` is related to the mean energy `U` and the absolute
thermodynamic entropy `S` by the fundamental identity `F = U - TS`. This theorem shows that
the statistically-defined quantities in this framework correctly satisfy this cornerstone of
thermodynamics. -/
theorem helmholtzFreeEnergy_eq_meanEnergy_sub_temp_mul_thermodynamicEntropy
    (T : Temperature) (hT : 0 < T.val)
    [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº]
    (hE : Integrable ùìí.energy (ùìí.ŒºProd T)) :
    ùìí.helmholtzFreeEnergy T
      = ùìí.meanEnergy T - T.val * ùìí.thermodynamicEntropy T := by
  classical
  have hSdiff :=
    ùìí.differentialEntropy_eq_kB_beta_meanEnergy_add_kB_log_mathZ
      (T:=T) (hE:=hE)
  have hScorr :=
    ùìí.thermodynamicEntropy_eq_differentialEntropy_sub_correction
      (T:=T) (hT:=hT) (hE:=hE)
  have hkŒ≤ : (kB : ‚Ñù) * (T.Œ≤ : ‚Ñù) = 1 / T.val :=
    kB_mul_beta T hT
  have hTne : (T.val : ‚Ñù) ‚â† 0 := by exact_mod_cast (ne_of_gt hT)
  have hS_form :
      ùìí.thermodynamicEntropy T
        = kB * (T.Œ≤ : ‚Ñù) * ùìí.meanEnergy T
            + kB * Real.log (ùìí.mathematicalPartitionFunction T)
            - kB * ùìí.dof * Real.log ùìí.phase_space_unit := by
    calc
      ùìí.thermodynamicEntropy T
          = ùìí.differentialEntropy T
              - kB * ùìí.dof * Real.log ùìí.phase_space_unit := hScorr
      _ = (kB * (T.Œ≤ : ‚Ñù) * ùìí.meanEnergy T
              + kB * Real.log (ùìí.mathematicalPartitionFunction T))
            - kB * ùìí.dof * Real.log ùìí.phase_space_unit := by
              simp [hSdiff]
      _ = _ := by
              simp [add_comm, add_left_comm, add_assoc, sub_eq_add_neg,
                    mul_comm, mul_left_comm, mul_assoc]
  have hkŒ≤T : T.val * (kB * (T.Œ≤ : ‚Ñù)) = 1 := by
    simp [hkŒ≤, hTne]
  have h_rhs :
      ùìí.meanEnergy T - T.val * ùìí.thermodynamicEntropy T
        = -kB * T.val *
            (Real.log (ùìí.mathematicalPartitionFunction T)
              - (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit) := by
    have := hS_form
    calc
      ùìí.meanEnergy T - T.val * ùìí.thermodynamicEntropy T
          = ùìí.meanEnergy T -
              T.val *
                (kB * (T.Œ≤ : ‚Ñù) * ùìí.meanEnergy T
                  + kB * Real.log (ùìí.mathematicalPartitionFunction T)
                  - kB * ùìí.dof * Real.log ùìí.phase_space_unit) := by
                rw [this]
      _ = ùìí.meanEnergy T
            - T.val * (kB * (T.Œ≤ : ‚Ñù)) * ùìí.meanEnergy T
            - T.val * kB * Real.log (ùìí.mathematicalPartitionFunction T)
            + T.val * kB * ùìí.dof * Real.log ùìí.phase_space_unit := by
              ring
      _ = ùìí.meanEnergy T - 1 * ùìí.meanEnergy T
            - T.val * kB * Real.log (ùìí.mathematicalPartitionFunction T)
            + T.val * kB * ùìí.dof * Real.log ùìí.phase_space_unit := by
              simp [hkŒ≤T, mul_comm, mul_left_comm, mul_assoc]
      _ = -kB * T.val *
            (Real.log (ùìí.mathematicalPartitionFunction T)
              - (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit) := by
              simp [sub_eq_add_neg, mul_comm, mul_left_comm, mul_assoc]
              ring
  have hZpos := ùìí.mathematicalPartitionFunction_pos T
  have hhpos : 0 < ùìí.phase_space_unit ^ ùìí.dof := pow_pos ùìí.h_pos _
  have hF_rewrite :
      ùìí.helmholtzFreeEnergy T
        = -kB * T.val *
            (Real.log (ùìí.mathematicalPartitionFunction T)
              - (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit) := by
    have h_log_pow :
        Real.log (ùìí.phase_space_unit ^ ùìí.dof)
          = (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit := by simp
    simp [helmholtzFreeEnergy, partitionFunction,
          Real.log_div hZpos.ne' hhpos.ne',
          Real.log_pow, h_log_pow,
          sub_eq_add_neg,
          mul_add, add_comm, add_left_comm, add_assoc,
          mul_comm, mul_left_comm, mul_assoc]
  rw [hF_rewrite, h_rhs]

/-- **Theorem: Helmholtz identity with semi‚Äìclassical correction term**.
Physical identity (always true for `T > 0`):
  (U - F)/T   = S_thermo
and:
  S_thermo = S_diff - kB * dof * log h.
Hence:
  S_diff = (U - F)/T + kB * dof * log h.
This theorem gives the correct relation for the (mathematical / differential) entropy.
(Removing the correction is only valid in normalized discrete cases
with `dof = 0` (or `phase_space_unit = 1`).) -/
theorem differentialEntropy_eq_meanEnergy_sub_helmholtz_div_temp_add_correction
    (ùìí : CanonicalEnsemble Œπ) (T : Temperature)
    [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº]
    (hT : 0 < T.val)
    (hE : Integrable ùìí.energy (ùìí.ŒºProd T)) :
    ùìí.differentialEntropy T
      = (ùìí.meanEnergy T - ùìí.helmholtzFreeEnergy T) / T.val
        + kB * ùìí.dof * Real.log ùìí.phase_space_unit := by
  classical
  have hS :=
    differentialEntropy_eq_kB_beta_meanEnergy_add_kB_log_mathZ (ùìí:=ùìí) (T:=T) hE
  set E := ùìí.meanEnergy T
  set Zmath := ùìí.mathematicalPartitionFunction T
  set Zphys := ùìí.partitionFunction T
  have Tne : (T.val : ‚Ñù) ‚â† 0 := by exact_mod_cast (ne_of_gt hT)
  have hkŒ≤ : kB * (T.Œ≤ : ‚Ñù) = 1 / (T.val : ‚Ñù) := by
    unfold Temperature.Œ≤
    change kB * (1 / (kB * (T.val : ‚Ñù))) = 1 / (T.val : ‚Ñù)
    field_simp [Constants.kB_neq_zero, Tne]
  have hS' :
      ùìí.differentialEntropy T = E / T.val + kB * Real.log Zmath := by
    rw [hS, hkŒ≤]
    simp [E, div_eq_mul_inv, mul_comm, mul_left_comm, mul_assoc]
  have hZdef : Zmath = Zphys * ùìí.phase_space_unit ^ ùìí.dof := by
    unfold Zmath Zphys CanonicalEnsemble.partitionFunction
    have hne : (ùìí.phase_space_unit ^ ùìí.dof) ‚â† 0 :=
      pow_ne_zero _ (ne_of_gt ùìí.h_pos)
    simp [div_eq_mul_inv, mul_comm, mul_left_comm, mul_assoc, hne]
  have hpow_pos : 0 < ùìí.phase_space_unit ^ ùìí.dof := pow_pos ùìí.h_pos _
  have hZmath_pos :
      0 < Zmath := (mathematicalPartitionFunction_pos (ùìí:=ùìí) (T:=T))
  have hZphys_pos :
      0 < Zphys := by
    have : Zphys = Zmath / ùìí.phase_space_unit ^ ùìí.dof := by
      simp [Zphys, CanonicalEnsemble.partitionFunction, div_eq_mul_inv]
      exact Or.symm (Or.inr rfl)
    have hden_pos : 0 < ùìí.phase_space_unit ^ ùìí.dof := hpow_pos
    simp [this, hZmath_pos, hden_pos]
  have hlog :
      Real.log Zmath
        = Real.log Zphys + (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit := by
    have hx : 0 < Zphys := hZphys_pos
    have hy : 0 < ùìí.phase_space_unit ^ ùìí.dof := hpow_pos
    have hlog_pow :
        Real.log (ùìí.phase_space_unit ^ ùìí.dof)
          = (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit := by
      simp
    calc
      Real.log Zmath
          = Real.log (Zphys * ùìí.phase_space_unit ^ ùìí.dof) := by simp [hZdef, mul_comm,
            mul_left_comm, mul_assoc]
      _ = Real.log Zphys + Real.log (ùìí.phase_space_unit ^ ùìí.dof) := by
        have hx0 : Zphys ‚â† 0 := ne_of_gt hx
        have hy0 : ùìí.phase_space_unit ^ ùìí.dof ‚â† 0 := ne_of_gt hy
        simpa [mul_comm, mul_left_comm, mul_assoc] using (Real.log_mul hx0 hy0)
      _ = Real.log Zphys + (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit := by simp [hlog_pow]
  have hS_phys :
      ùìí.differentialEntropy T
        = E / T.val + kB * Real.log Zphys
          + kB * (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit := by
    rw [hS', hlog]
    ring
  have hF :
      ùìí.helmholtzFreeEnergy T = - kB * T.val * Real.log Zphys := rfl
  have hEF :
      (E - ùìí.helmholtzFreeEnergy T) / T.val
        = E / T.val + kB * Real.log Zphys := by
    simp [hF, sub_eq_add_neg, division_def, mul_add,
      add_comm, add_left_comm, add_assoc,
      mul_comm, mul_left_comm, mul_assoc, E, Zphys, Tne]
  calc
    ùìí.differentialEntropy T
        = (E / T.val + kB * Real.log Zphys)
            + kB * (ùìí.dof : ‚Ñù) * Real.log ùìí.phase_space_unit := by
              simp [hS_phys, add_comm, add_left_comm, add_assoc]
    _ = (E - ùìí.helmholtzFreeEnergy T) / T.val
            + kB * ùìí.dof * Real.log ùìí.phase_space_unit := by
              rw [hEF]

/-- Discrete / normalized specialization of the previous theorem.
If either `dof = 0` (no semiclassical correction) or `phase_space_unit = 1`
(so `log h = 0`), the correction term vanishes and we recover the bare Helmholtz identity
for the (differential) entropy. -/
lemma differentialEntropy_eq_meanEnergy_sub_helmholtz_div_temp
    (ùìí : CanonicalEnsemble Œπ) (T : Temperature)
    [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº]
    (hT : 0 < T.val)
    (hE : Integrable ùìí.energy (ùìí.ŒºProd T))
    (hNorm : ùìí.dof = 0 ‚à® ùìí.phase_space_unit = 1) :
    ùìí.differentialEntropy T
      = (ùìí.meanEnergy T - ùìí.helmholtzFreeEnergy T) / T.val := by
  have hmain :=
    differentialEntropy_eq_meanEnergy_sub_helmholtz_div_temp_add_correction
      (ùìí:=ùìí) (T:=T) hT hE
  rcases hNorm with hDof | hUnit
  ¬∑ -- dof = 0
    simp [hmain, hDof]
  ¬∑ -- phase_space_unit = 1 ‚áí log = 0
    simp [hmain, hUnit]

open scoped Topology ENNReal

/-- Positivity of `Œ≤` from positivity of temperature. -/
lemma beta_pos (T : Temperature) (hT_pos : 0 < T.val) : 0 < (T.Œ≤ : ‚Ñù) := by
  unfold Temperature.Œ≤
  have h_prod : 0 < (kB : ‚Ñù) * T.val := mul_pos kB_pos hT_pos
  simpa [Temperature.Œ≤] using inv_pos.mpr h_prod

/-- Chain rule convenience lemma for `log ‚àò f` on a set. -/
lemma hasDerivWithinAt_log_comp
    {f : ‚Ñù ‚Üí ‚Ñù} {f' : ‚Ñù} {s : Set ‚Ñù} {x : ‚Ñù}
    (hf : HasDerivWithinAt f f' s x) (hx : f x ‚â† 0) :
    HasDerivWithinAt (fun t => Real.log (f t)) ((f x)‚Åª¬π * f') s x :=
  (Real.hasDerivAt_log hx).comp_hasDerivWithinAt x hf

/-- A version rewriting the derivative value with `1 / f x`. -/
lemma hasDerivWithinAt_log_comp'
    {f : ‚Ñù ‚Üí ‚Ñù} {f' : ‚Ñù} {s : Set ‚Ñù} {x : ‚Ñù}
    (hf : HasDerivWithinAt f f' s x) (hx : f x ‚â† 0) :
    HasDerivWithinAt (fun t => Real.log (f t))
      ((1 / f x) * f') s x := by
  simpa [one_div, mul_comm, mul_left_comm, mul_assoc]
    using (hasDerivWithinAt_log_comp (f:=f) (f':=f') (s:=s) (x:=x) hf hx)

lemma integral_bolt_eq_integral_mul_exp
    {Œπ} [MeasurableSpace Œπ] (ùìí : CanonicalEnsemble Œπ) (T : Temperature)
    (œÜ : Œπ ‚Üí ‚Ñù) : --(hœÜm : Measurable œÜ)
    --(h_int : Integrable (fun x => œÜ x * Real.exp (-T.Œ≤ * ùìí.energy x)) ùìí.Œº) :
    ‚à´ x, œÜ x ‚àÇ ùìí.ŒºBolt T
      = ‚à´ x, œÜ x * Real.exp (-T.Œ≤ * ùìí.energy x) ‚àÇ ùìí.Œº := by
  unfold CanonicalEnsemble.ŒºBolt
  set f : Œπ ‚Üí ‚Ñù‚â•0‚àû := fun x => ENNReal.ofReal (Real.exp (-T.Œ≤ * ùìí.energy x))
  have hf_meas : Measurable f := by
    fun_prop
  have hf_lt_top : ‚àÄ·µê x ‚àÇ ùìí.Œº, f x < ‚àû := by
    simp [f]
  have h :=
    integral_withDensity_eq_integral_toReal_smul
      (Œº := ùìí.Œº) hf_meas hf_lt_top œÜ
  have h_toReal : ‚àÄ x, (f x).toReal = Real.exp (-T.Œ≤ * ùìí.energy x) := by
    intro x
    have h_nonneg : (0 : ‚Ñù) ‚â§ Real.exp (-T.Œ≤ * ùìí.energy x) :=
      (Real.exp_pos _).le
    simpa [f, h_nonneg] using ENNReal.toReal_ofReal h_nonneg
  have h' :
    (‚à´ x, œÜ x ‚àÇ ùìí.Œº.withDensity f) =
      ‚à´ x, œÜ x * Real.exp (-T.Œ≤ * ùìí.energy x) ‚àÇ ùìí.Œº := by
    simpa [h_toReal, smul_eq_mul, mul_comm] using h
  simpa [f, mul_comm] using h'

set_option linter.unusedVariables false in
/--  A specialization of `integral_bolt_eq_integral_mul_exp`
to the **energy** observable. -/
lemma integral_energy_bolt
    {Œπ} [MeasurableSpace Œπ] (ùìí : CanonicalEnsemble Œπ) (T : Temperature)
    (hE : Integrable ùìí.energy (ùìí.ŒºBolt T)) :
    ‚à´ x, ùìí.energy x ‚àÇ ùìí.ŒºBolt T
      = ‚à´ x, ùìí.energy x * Real.exp (-T.Œ≤ * ùìí.energy x) ‚àÇ ùìí.Œº := by
  exact integral_bolt_eq_integral_mul_exp ùìí T ùìí.energy

lemma meanEnergy_eq_ratio_of_integrals
    (ùìí : CanonicalEnsemble Œπ) (T : Temperature)
    [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº]
    (hE : Integrable ùìí.energy (ùìí.ŒºBolt T)) :
    ùìí.meanEnergy T =
      (‚à´ i, ùìí.energy i * Real.exp (- T.Œ≤ * ùìí.energy i) ‚àÇ ùìí.Œº) /
        (‚à´ i, Real.exp (- T.Œ≤ * ùìí.energy i) ‚àÇ ùìí.Œº) := by
  classical
  unfold CanonicalEnsemble.meanEnergy CanonicalEnsemble.ŒºProd
  have h_scale :
      ‚à´ x, ùìí.energy x ‚àÇ ((ùìí.ŒºBolt T Set.univ)‚Åª¬π ‚Ä¢ ùìí.ŒºBolt T)
        = ((ùìí.ŒºBolt T Set.univ)‚Åª¬π).toReal * ‚à´ x, ùìí.energy x ‚àÇ ùìí.ŒºBolt T := by
    simp
  have h_energy_bolt_raw :=
    CanonicalEnsemble.integral_energy_bolt (ùìí:=ùìí) (T:=T) hE
  have h_den :
      (ùìí.ŒºBolt T Set.univ).toReal
        = ‚à´ x, Real.exp (- T.Œ≤ * ùìí.energy x) ‚àÇ ùìí.Œº := by
    simpa [CanonicalEnsemble.mathematicalPartitionFunction]
      using (mathematicalPartitionFunction_eq_integral (ùìí:=ùìí) (T:=T))
  have h_den :
      (ùìí.ŒºBolt T Set.univ).toReal
        = ‚à´ x, Real.exp (- T.Œ≤ * ùìí.energy x) ‚àÇ ùìí.Œº := by
    have hZ := ùìí.mathematicalPartitionFunction_eq_integral T
    have : (ùìí.ŒºBolt T Set.univ).toReal = ùìí.mathematicalPartitionFunction T := by
      simp [CanonicalEnsemble.mathematicalPartitionFunction]
      rw [‚Üê @measureReal_def]
    simpa [this] using hZ
  have h_inv_toReal :
      ((ùìí.ŒºBolt T Set.univ)‚Åª¬π).toReal
        = 1 / (ùìí.ŒºBolt T Set.univ).toReal := by
    have hfin : (ùìí.ŒºBolt T Set.univ) ‚â† ‚àû := by simp
    have h0 : (ùìí.ŒºBolt T Set.univ) ‚â† 0 := by
      have hŒºBoltNe : ùìí.ŒºBolt T ‚â† 0 :=
        (inferInstance : NeZero (ùìí.ŒºBolt T)).out
      intro hZero
      have : ùìí.ŒºBolt T = 0 := by
        simpa [Measure.measure_univ_eq_zero] using hZero
      exact hŒºBoltNe this
    simp [one_div, ENNReal.toReal_inv, h0, hfin]
  calc
    ‚à´ x, ùìí.energy x ‚àÇ ((ùìí.ŒºBolt T Set.univ)‚Åª¬π ‚Ä¢ ùìí.ŒºBolt T)
        = ((ùìí.ŒºBolt T Set.univ)‚Åª¬π).toReal * ‚à´ x, ùìí.energy x ‚àÇ ùìí.ŒºBolt T := h_scale
    _ = ((ùìí.ŒºBolt T Set.univ)‚Åª¬π).toReal *
          (‚à´ x, ùìí.energy x * Real.exp (- T.Œ≤ * ùìí.energy x) ‚àÇ ùìí.Œº) := by
          simp [h_energy_bolt_raw]
    _ = (1 / (ùìí.ŒºBolt T Set.univ).toReal) *
          (‚à´ x, ùìí.energy x * Real.exp (- T.Œ≤ * ùìí.energy x) ‚àÇ ùìí.Œº) := by
          simp [h_inv_toReal]
    _ = (‚à´ x, ùìí.energy x * Real.exp (- T.Œ≤ * ùìí.energy x) ‚àÇ ùìí.Œº) /
          (‚à´ x, Real.exp (- T.Œ≤ * ùìí.energy x) ‚àÇ ùìí.Œº) := by
          simp [h_den, div_eq_mul_inv, mul_comm, mul_left_comm, mul_assoc]

/-- The mean energy is the negative derivative of the logarithm of the
(mathematical) partition function with respect to Œ≤ = 1/(kB T).
see: Tong (¬ß1.3.2, ¬ß1.3.3), L&L (¬ß31, implicitly, and ¬ß36)
Here the derivative is a `derivWithin` over `Set.Ioi 0`
since `Œ≤ > 0`. -/
theorem meanEnergy_eq_neg_deriv_log_mathZ_of_beta
    (ùìí : CanonicalEnsemble Œπ) (T : Temperature)
    (hT_pos : 0 < T.val) [IsFiniteMeasure (ùìí.ŒºBolt T)] [NeZero ùìí.Œº]
    (hE_bolt : Integrable ùìí.energy (ùìí.ŒºBolt T))
    (h_deriv :
        HasDerivWithinAt
          (fun Œ≤ : ‚Ñù => ‚à´ i, Real.exp (-Œ≤ * ùìí.energy i) ‚àÇ ùìí.Œº)
          (- ‚à´ i, ùìí.energy i * Real.exp (-(T.Œ≤ : ‚Ñù) * ùìí.energy i) ‚àÇùìí.Œº)
          (Set.Ioi 0) (T.Œ≤ : ‚Ñù)) :
    ùìí.meanEnergy T =
      - (derivWithin
          (fun Œ≤ : ‚Ñù => Real.log (‚à´ i, Real.exp (-Œ≤ * ùìí.energy i) ‚àÇùìí.Œº))
          (Set.Ioi 0) (T.Œ≤ : ‚Ñù)) := by
  classical
  set f : ‚Ñù ‚Üí ‚Ñù := fun Œ≤ => ‚à´ i, Real.exp (-Œ≤ * ùìí.energy i) ‚àÇùìí.Œº
  have hŒ≤_pos : 0 < (T.Œ≤ : ‚Ñù) := beta_pos T hT_pos
  have hZpos : 0 < f (T.Œ≤ : ‚Ñù) := by
    have hZ := mathematicalPartitionFunction_pos (ùìí:=ùìí) (T:=T)
    have hEq : f (T.Œ≤ : ‚Ñù) = ùìí.mathematicalPartitionFunction T := by
      simp [f, mathematicalPartitionFunction_eq_integral (ùìí:=ùìí) (T:=T)]
    simpa [hEq] using hZ
  have h_log :
      HasDerivWithinAt
        (fun Œ≤ : ‚Ñù => Real.log (f Œ≤))
        ((1 / f (T.Œ≤ : ‚Ñù)) *
            (- ‚à´ i, ùìí.energy i * Real.exp (-(T.Œ≤ : ‚Ñù) * ùìí.energy i) ‚àÇùìí.Œº))
        (Set.Ioi 0) (T.Œ≤ : ‚Ñù) := by
    have h‚ÇÅ :=
      CanonicalEnsemble.hasDerivWithinAt_log_comp'
        (hf := h_deriv) (hx := (ne_of_gt hZpos))
    simpa [f] using h‚ÇÅ
  have h_mean_ratio :
      ùìí.meanEnergy T =
        (‚à´ i, ùìí.energy i * Real.exp (-(T.Œ≤ : ‚Ñù) * ùìí.energy i) ‚àÇùìí.Œº) /
          (‚à´ i, Real.exp (-(T.Œ≤ : ‚Ñù) * ùìí.energy i) ‚àÇùìí.Œº) := by
    simpa [neg_mul, mul_comm, mul_left_comm, mul_assoc]
      using meanEnergy_eq_ratio_of_integrals (ùìí:=ùìí) (T:=T) (hE := hE_bolt)
  have h_mem : (T.Œ≤ : ‚Ñù) ‚àà Set.Ioi (0:‚Ñù) := hŒ≤_pos
  have hUD : UniqueDiffWithinAt ‚Ñù (Set.Ioi (0:‚Ñù)) (T.Œ≤ : ‚Ñù) :=
    isOpen_Ioi.uniqueDiffWithinAt h_mem
  have h_deriv_log :
      derivWithin (fun Œ≤ : ‚Ñù => Real.log (f Œ≤)) (Set.Ioi 0) (T.Œ≤ : ‚Ñù)
        = (1 / f (T.Œ≤ : ‚Ñù)) *
            (- ‚à´ i, ùìí.energy i * Real.exp (-(T.Œ≤ : ‚Ñù) * ùìí.energy i) ‚àÇùìí.Œº) :=
    h_log.derivWithin hUD
  have h_f_eval :
      f (T.Œ≤ : ‚Ñù) = ‚à´ i, Real.exp (-(T.Œ≤ : ‚Ñù) * ùìí.energy i) ‚àÇùìí.Œº := rfl
  have h_ratio :
      (‚à´ i, ùìí.energy i * Real.exp (-(T.Œ≤ : ‚Ñù) * ùìí.energy i) ‚àÇùìí.Œº) /
          (‚à´ i, Real.exp (-(T.Œ≤ : ‚Ñù) * ùìí.energy i) ‚àÇùìí.Œº)
        = (1 / f (T.Œ≤ : ‚Ñù)) *
            (‚à´ i, ùìí.energy i * Real.exp (-(T.Œ≤ : ‚Ñù) * ùìí.energy i) ‚àÇùìí.Œº) := by
    simp [h_f_eval, div_eq_mul_inv, mul_comm, mul_left_comm, mul_assoc]
  calc
    ùìí.meanEnergy T
        = _ := h_mean_ratio
    _ = (1 / f (T.Œ≤ : ‚Ñù)) *
            (‚à´ i, ùìí.energy i * Real.exp (-(T.Œ≤ : ‚Ñù) * ùìí.energy i) ‚àÇùìí.Œº) := h_ratio
    _ = - ((1 / f (T.Œ≤ : ‚Ñù)) *
            (- ‚à´ i, ùìí.energy i * Real.exp (-(T.Œ≤ : ‚Ñù) * ùìí.energy i) ‚àÇùìí.Œº)) := by ring
    _ = - (derivWithin
            (fun Œ≤ : ‚Ñù => Real.log (‚à´ i, Real.exp (-Œ≤ * ùìí.energy i) ‚àÇùìí.Œº))
            (Set.Ioi 0) (T.Œ≤ : ‚Ñù)) := by
          rw [h_deriv_log]

end CanonicalEnsemble
