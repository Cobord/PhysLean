/-
Copyright (c) 2024 Joseph Tooby-Smith. All rights reserved.
Released under Apache 2.0 license.
Authors: Joseph Tooby-Smith
-/
import HepLean.StandardModel.Basic
import HepLean.StandardModel.Representations
import Mathlib.Data.Complex.Exponential
import Mathlib.Tactic.Polyrith
import Mathlib.Geometry.Manifold.VectorBundle.Basic
import Mathlib.Geometry.Manifold.VectorBundle.SmoothSection
import Mathlib.Geometry.Manifold.Instances.Real
import Mathlib.RepresentationTheory.Basic
import Mathlib.Analysis.InnerProductSpace.Basic
import Mathlib.Analysis.InnerProductSpace.Adjoint
import Mathlib.Geometry.Manifold.ContMDiff.Product
import Mathlib.Algebra.QuadraticDiscriminant
/-!
# The Higgs vector space

This file defines the target vector space of the Higgs boson, the potential on it,
and the representation of the SM gauge group acting on it.

This file is a import of `SM.HiggsBoson.Basic`.

## References

- We use conventions given in: https://pdg.lbl.gov/2019/reviews/rpp2019-rev-higgs-boson.pdf

-/
universe v u
namespace StandardModel
noncomputable section

open Manifold
open Matrix
open Complex
open ComplexConjugate

/-- The complex vector space in which the Higgs field takes values. -/
abbrev higgsVec := EuclideanSpace ‚ÑÇ (Fin 2)

section higgsVec

/-- The continous linear map from the vector space `higgsVec` to `(Fin 2 ‚Üí ‚ÑÇ)` acheived by
casting vectors. -/
def higgsVecToFin2‚ÑÇ : higgsVec ‚ÜíL[‚Ñù] (Fin 2 ‚Üí ‚ÑÇ) where
  toFun x := x
  map_add' x y := by
    simp
  map_smul' a x := by
    simp

lemma smooth_higgsVecToFin2‚ÑÇ : Smooth ùìò(‚Ñù, higgsVec) ùìò(‚Ñù, Fin 2 ‚Üí ‚ÑÇ) higgsVecToFin2‚ÑÇ :=
  ContinuousLinearMap.smooth higgsVecToFin2‚ÑÇ

namespace higgsVec

@[simps!]
noncomputable def higgsRepUnitary : guageGroup ‚Üí* unitaryGroup (Fin 2) ‚ÑÇ where
  toFun g := repU1 g.2.2 * fundamentalSU2 g.2.1
  map_mul'  := by
    intro ‚ü®_, a2, a3‚ü© ‚ü®_, b2, b3‚ü©
    change repU1 (a3 * b3) *  fundamentalSU2 (a2 * b2) = _
    rw [repU1.map_mul, fundamentalSU2.map_mul]
    rw [mul_assoc, mul_assoc, ‚Üê mul_assoc (repU1 b3) _ _, repU1_fundamentalSU2_commute]
    repeat rw [mul_assoc]
  map_one' := by
    simp only [Prod.snd_one, _root_.map_one, Prod.fst_one, mul_one]

/-- An orthonomral basis of higgsVec. -/
noncomputable def orthonormBasis : OrthonormalBasis (Fin 2) ‚ÑÇ higgsVec :=
  EuclideanSpace.basisFun (Fin 2) ‚ÑÇ

/-- Takes in a `2√ó2`-matrix and returns a linear map of `higgsVec`. -/
@[simps!]
noncomputable def matrixToLin : Matrix (Fin 2) (Fin 2) ‚ÑÇ ‚Üí* (higgsVec ‚ÜíL[‚ÑÇ] higgsVec) where
  toFun g := LinearMap.toContinuousLinearMap
    $ Matrix.toLin orthonormBasis.toBasis orthonormBasis.toBasis g
  map_mul' g h := ContinuousLinearMap.coe_inj.mp $
    Matrix.toLin_mul orthonormBasis.toBasis orthonormBasis.toBasis orthonormBasis.toBasis g h
  map_one' := ContinuousLinearMap.coe_inj.mp $ Matrix.toLin_one orthonormBasis.toBasis

lemma matrixToLin_star (g : Matrix (Fin 2) (Fin 2) ‚ÑÇ) :
    matrixToLin (star g) = star (matrixToLin g) :=
  ContinuousLinearMap.coe_inj.mp $ Matrix.toLin_conjTranspose orthonormBasis orthonormBasis g

lemma matrixToLin_unitary (g : unitaryGroup (Fin 2) ‚ÑÇ) :
    matrixToLin g ‚àà unitary (higgsVec ‚ÜíL[‚ÑÇ] higgsVec) := by
  rw [@unitary.mem_iff, ‚Üê matrixToLin_star, ‚Üê matrixToLin.map_mul, ‚Üê matrixToLin.map_mul]
  rw [mem_unitaryGroup_iff.mp g.prop, mem_unitaryGroup_iff'.mp g.prop, matrixToLin.map_one]
  simp

@[simps!]
noncomputable def unitaryToLin : unitaryGroup (Fin 2) ‚ÑÇ ‚Üí* unitary (higgsVec ‚ÜíL[‚ÑÇ] higgsVec) where
  toFun g := ‚ü®matrixToLin g, matrixToLin_unitary g‚ü©
  map_mul' g h := by
    ext
    simp
  map_one' := by
    ext
    simp

@[simps!]
def unitToLinear : unitary (higgsVec ‚ÜíL[‚ÑÇ] higgsVec) ‚Üí* higgsVec ‚Üí‚Çó[‚ÑÇ] higgsVec :=
  DistribMulAction.toModuleEnd ‚ÑÇ higgsVec

@[simps!]
def rep : Representation ‚ÑÇ guageGroup higgsVec :=
   unitToLinear.comp (unitaryToLin.comp higgsRepUnitary)

lemma higgsRepUnitary_mul (g : guageGroup) (œÜ : higgsVec) :
    (higgsRepUnitary g).1 *·µ• œÜ = g.2.2 ^ 3 ‚Ä¢ (g.2.1.1 *·µ• œÜ) := by
  simp only [higgsRepUnitary_apply_coe]
  exact smul_mulVec_assoc (g.2.2 ^ 3) (g.2.1.1) œÜ

lemma rep_apply (g : guageGroup) (œÜ : higgsVec) : rep g œÜ = g.2.2 ^ 3 ‚Ä¢ (g.2.1.1 *·µ• œÜ) :=
  higgsRepUnitary_mul g œÜ


lemma norm_invariant (g : guageGroup) (œÜ : higgsVec) : ‚Äñrep g œÜ‚Äñ = ‚ÄñœÜ‚Äñ :=
  ContinuousLinearMap.norm_map_of_mem_unitary (unitaryToLin (higgsRepUnitary g)).2 œÜ

/-- The higgs potential for `higgsVec`, i.e. for constant higgs fields. -/
def potential (ŒºSq lambda : ‚Ñù) (œÜ : higgsVec) : ‚Ñù := - ŒºSq  * ‚ÄñœÜ‚Äñ ^ 2  +
  lambda * ‚ÄñœÜ‚Äñ ^ 4

lemma potential_invariant (ŒºSq lambda : ‚Ñù) (œÜ : higgsVec)  (g : guageGroup) :
    potential ŒºSq lambda (rep g œÜ) = potential ŒºSq lambda œÜ := by
  simp only [potential, neg_mul]
  rw [norm_invariant]

lemma potential_snd_term_nonneg {lambda : ‚Ñù} (hLam : 0 < lambda) (œÜ : higgsVec) :
    0 ‚â§ lambda * ‚ÄñœÜ‚Äñ ^ 4 := by
  rw [mul_nonneg_iff]
  apply Or.inl
  simp_all only [ge_iff_le, norm_nonneg, pow_nonneg, and_true]
  exact le_of_lt hLam

lemma potential_as_quad (ŒºSq lambda : ‚Ñù) (œÜ : higgsVec) :
    lambda  * ‚ÄñœÜ‚Äñ ^ 2 * ‚ÄñœÜ‚Äñ ^ 2 + (- ŒºSq ) * ‚ÄñœÜ‚Äñ ^ 2 + (- potential ŒºSq lambda œÜ ) = 0 := by
  simp [potential]
  ring

lemma zero_le_potential_discrim (ŒºSq lambda : ‚Ñù) (œÜ : higgsVec) (hLam : 0 < lambda) :
    0 ‚â§ discrim (lambda) (- ŒºSq ) (- potential ŒºSq lambda œÜ) := by
  have h1 := potential_as_quad ŒºSq lambda œÜ
  rw [quadratic_eq_zero_iff_discrim_eq_sq] at h1
  rw [h1]
  exact sq_nonneg (2 * (lambda ) * ‚ÄñœÜ‚Äñ ^ 2 + -ŒºSq)
  simp only [ne_eq, div_eq_zero_iff, OfNat.ofNat_ne_zero, or_false]
  exact ne_of_gt hLam


lemma potential_eq_zero_sol (ŒºSq lambda : ‚Ñù) (hLam : 0 < lambda)(œÜ : higgsVec)
    (hV : potential ŒºSq lambda œÜ = 0) : œÜ = 0 ‚à® ‚ÄñœÜ‚Äñ ^ 2 = ŒºSq / lambda := by
  have h1 := potential_as_quad ŒºSq lambda œÜ
  rw [hV] at h1
  have h2 : ‚ÄñœÜ‚Äñ ^ 2 * (lambda  * ‚ÄñœÜ‚Äñ ^ 2  + -ŒºSq ) = 0 := by
    linear_combination h1
  simp at h2
  cases' h2 with h2 h2
  simp_all
  apply Or.inr
  field_simp at h2 ‚ä¢
  ring_nf
  linear_combination h2

lemma potential_eq_zero_sol_of_ŒºSq_nonpos {ŒºSq lambda : ‚Ñù} (hLam : 0 < lambda) (hŒºSq : ŒºSq ‚â§ 0)
    (œÜ : higgsVec)  (hV : potential ŒºSq lambda œÜ = 0) : œÜ = 0 := by
  cases' (potential_eq_zero_sol ŒºSq lambda hLam œÜ hV) with h1 h1
  exact h1
  by_cases hŒºSqZ : ŒºSq = 0
  simpa [hŒºSqZ] using h1
  refine ((?_ : ¬¨ 0 ‚â§  ŒºSq / lambda) (?_)).elim
  ¬∑ simp_all [div_nonneg_iff]
    intro h
    exact lt_imp_lt_of_le_imp_le (fun _ => h) (lt_of_le_of_ne hŒºSq hŒºSqZ)
  ¬∑ rw [‚Üê h1]
    exact sq_nonneg ‚ÄñœÜ‚Äñ

lemma potential_bounded_below (ŒºSq lambda : ‚Ñù) (hLam : 0 < lambda) (œÜ : higgsVec) :
    - ŒºSq ^ 2 / (4 * lambda) ‚â§ potential ŒºSq lambda œÜ  := by
  have h1 := zero_le_potential_discrim ŒºSq lambda œÜ hLam
  simp [discrim] at h1
  ring_nf at h1
  rw [‚Üê neg_le_iff_add_nonneg'] at h1
  have h3 : lambda * potential ŒºSq lambda œÜ * 4 = (4 * lambda) * potential ŒºSq lambda œÜ := by
    ring
  rw [h3] at h1
  have h2 :=  (div_le_iff' (by simp [hLam] : 0 < 4 * lambda )).mpr h1
  ring_nf at h2 ‚ä¢
  exact h2

lemma potential_bounded_below_of_ŒºSq_nonpos {ŒºSq lambda : ‚Ñù} (hLam : 0 < lambda)
    (hŒºSq : ŒºSq ‚â§ 0) (œÜ : higgsVec) : 0 ‚â§ potential ŒºSq lambda œÜ := by
  simp only [potential, neg_mul, add_zero]
  refine add_nonneg ?_ (potential_snd_term_nonneg hLam œÜ)
  field_simp
  rw [@mul_nonpos_iff]
  simp_all only [ge_iff_le, norm_nonneg, pow_nonneg, and_self, or_true]


lemma potential_eq_bound_discrim_zero (ŒºSq lambda : ‚Ñù) (hLam : 0 < lambda)(œÜ : higgsVec)
    (hV : potential ŒºSq lambda œÜ = - ŒºSq ^ 2 / (4  * lambda)) :
    discrim (lambda) (- ŒºSq) (- potential ŒºSq lambda œÜ) = 0 := by
  simp [discrim, hV]
  field_simp
  ring

lemma potential_eq_bound_higgsVec_sq (ŒºSq lambda : ‚Ñù) (hLam : 0 < lambda)(œÜ : higgsVec)
    (hV : potential ŒºSq lambda œÜ = - ŒºSq ^ 2 / (4  * lambda)) :
    ‚ÄñœÜ‚Äñ ^ 2 = ŒºSq / (2 * lambda) := by
  have h1 := potential_as_quad ŒºSq lambda œÜ
  rw [quadratic_eq_zero_iff_of_discrim_eq_zero _
    (potential_eq_bound_discrim_zero ŒºSq lambda hLam œÜ hV)] at h1
  rw [h1]
  field_simp
  ring_nf
  simp only [ne_eq, div_eq_zero_iff, OfNat.ofNat_ne_zero, or_false]
  exact ne_of_gt hLam

lemma potential_eq_bound_iff (ŒºSq lambda : ‚Ñù) (hLam : 0 < lambda)(œÜ : higgsVec) :
    potential ŒºSq lambda œÜ = - ŒºSq ^ 2 / (4  * lambda) ‚Üî ‚ÄñœÜ‚Äñ ^ 2 = ŒºSq / (2 * lambda) := by
  apply Iff.intro
  ¬∑ intro h
    exact potential_eq_bound_higgsVec_sq ŒºSq lambda hLam œÜ h
  ¬∑ intro h
    have hv : ‚ÄñœÜ‚Äñ  ^ 4 = ‚ÄñœÜ‚Äñ ^ 2 * ‚ÄñœÜ‚Äñ ^ 2 := by
      ring_nf
    field_simp [potential, hv, h]
    ring

lemma potential_eq_bound_iff_of_ŒºSq_nonpos {ŒºSq lambda : ‚Ñù} (hLam : 0 < lambda)
    (hŒºSq : ŒºSq ‚â§ 0) (œÜ : higgsVec) : potential ŒºSq lambda œÜ = 0 ‚Üî œÜ = 0 := by
  apply Iff.intro
  ¬∑ intro h
    exact potential_eq_zero_sol_of_ŒºSq_nonpos hLam hŒºSq œÜ h
  ¬∑ intro h
    simp [potential, h]

lemma potential_eq_bound_IsMinOn (ŒºSq lambda : ‚Ñù) (hLam : 0 < lambda)  (œÜ : higgsVec)
    (hv : potential ŒºSq lambda œÜ = - ŒºSq ^ 2 / (4  * lambda)) :
    IsMinOn (potential ŒºSq lambda) Set.univ œÜ := by
  rw [isMinOn_univ_iff]
  intro x
  rw [hv]
  exact potential_bounded_below ŒºSq lambda hLam x

lemma potential_eq_bound_IsMinOn_of_ŒºSq_nonpos {ŒºSq lambda : ‚Ñù} (hLam : 0 < lambda)
    (hŒºSq : ŒºSq ‚â§ 0) (œÜ : higgsVec) (hv : potential ŒºSq lambda œÜ = 0) :
    IsMinOn (potential ŒºSq lambda) Set.univ œÜ := by
  rw [isMinOn_univ_iff]
  intro x
  rw [hv]
  exact potential_bounded_below_of_ŒºSq_nonpos hLam hŒºSq x

lemma potential_bound_reached_of_ŒºSq_nonneg {ŒºSq lambda : ‚Ñù} (hLam : 0 < lambda) (hŒºSq : 0 ‚â§ ŒºSq) :
    ‚àÉ (œÜ : higgsVec), potential ŒºSq lambda œÜ = - ŒºSq ^ 2 / (4  * lambda) := by
  use ![‚àö(ŒºSq/(2 * lambda)), 0]
  refine (potential_eq_bound_iff ŒºSq lambda hLam _).mpr ?_
  simp [@PiLp.norm_sq_eq_of_L2, Fin.sum_univ_two]
  field_simp [mul_pow]

lemma IsMinOn_potential_iff_of_ŒºSq_nonneg {ŒºSq lambda : ‚Ñù} (hLam : 0 < lambda) (hŒºSq : 0 ‚â§ ŒºSq) :
    IsMinOn (potential ŒºSq lambda) Set.univ œÜ ‚Üî ‚ÄñœÜ‚Äñ ^ 2 = ŒºSq /(2 * lambda) := by
  apply Iff.intro
  ¬∑ intro h
    obtain ‚ü®œÜm, hœÜ‚ü© := potential_bound_reached_of_ŒºSq_nonneg hLam hŒºSq
    have hm := isMinOn_univ_iff.mp h œÜm
    rw [hœÜ] at hm
    have h1 := potential_bounded_below ŒºSq lambda hLam œÜ
    rw [‚Üê potential_eq_bound_iff ŒºSq lambda hLam œÜ]
    exact (Real.partialOrder.le_antisymm _ _ h1 hm).symm
  ¬∑ intro h
    rw [‚Üê potential_eq_bound_iff ŒºSq lambda hLam œÜ] at h
    exact potential_eq_bound_IsMinOn ŒºSq lambda hLam œÜ h


lemma IsMinOn_potential_iff_of_ŒºSq_nonpos {ŒºSq lambda : ‚Ñù} (hLam : 0 < lambda) (hŒºSq : ŒºSq ‚â§ 0) :
    IsMinOn (potential ŒºSq lambda) Set.univ œÜ ‚Üî œÜ = 0 := by
  apply Iff.intro
  ¬∑ intro h
    have h0 := isMinOn_univ_iff.mp h 0
    rw [(potential_eq_bound_iff_of_ŒºSq_nonpos hLam hŒºSq 0).mpr (by rfl)] at h0
    have h1 := potential_bounded_below_of_ŒºSq_nonpos hLam hŒºSq œÜ
    rw [‚Üê (potential_eq_bound_iff_of_ŒºSq_nonpos hLam hŒºSq œÜ)]
    exact (Real.partialOrder.le_antisymm _ _ h1 h0).symm
  ¬∑ intro h
    rw [‚Üê potential_eq_bound_iff_of_ŒºSq_nonpos hLam hŒºSq œÜ] at h
    exact potential_eq_bound_IsMinOn_of_ŒºSq_nonpos hLam hŒºSq œÜ h

/-- Given a Higgs vector, a rotation matrix which puts the fst component of the
vector to zero, and the snd componenet to a real -/
def rotateMatrix (œÜ : higgsVec) : Matrix (Fin 2) (Fin 2) ‚ÑÇ :=
  ![![œÜ 1 /‚ÄñœÜ‚Äñ , - œÜ 0 /‚ÄñœÜ‚Äñ], ![conj (œÜ 0) / ‚ÄñœÜ‚Äñ , conj (œÜ 1) / ‚ÄñœÜ‚Äñ] ]

lemma rotateMatrix_star (œÜ : higgsVec) :
    star œÜ.rotateMatrix =
    ![![conj (œÜ 1) /‚ÄñœÜ‚Äñ ,  œÜ 0 /‚ÄñœÜ‚Äñ], ![- conj (œÜ 0) / ‚ÄñœÜ‚Äñ , œÜ 1 / ‚ÄñœÜ‚Äñ] ] := by
  simp [star]
  rw [rotateMatrix, conjTranspose]
  ext i j
  fin_cases i <;> fin_cases j <;> simp [conj_ofReal]


lemma rotateMatrix_det {œÜ : higgsVec} (hœÜ : œÜ ‚â† 0) : (rotateMatrix œÜ).det = 1 := by
  simp [rotateMatrix, det_fin_two]
  have h1 : (‚ÄñœÜ‚Äñ : ‚ÑÇ)  ‚â† 0 := ofReal_inj.mp.mt (norm_ne_zero_iff.mpr hœÜ)
  field_simp
  rw [‚Üê ofReal_mul, ‚Üê sq, ‚Üê @real_inner_self_eq_norm_sq]
  simp only [PiLp.inner_apply, Complex.inner,  neg_mul, sub_neg_eq_add,
    Fin.sum_univ_two, ofReal_add, ofReal_mul, mul_conj, mul_comm, add_comm]
  rfl

lemma rotateMatrix_unitary {œÜ : higgsVec} (hœÜ : œÜ ‚â† 0) :
    (rotateMatrix œÜ) ‚àà unitaryGroup (Fin 2) ‚ÑÇ := by
  rw [mem_unitaryGroup_iff', rotateMatrix_star, rotateMatrix]
  erw [mul_fin_two, one_fin_two]
  have : (‚ÄñœÜ‚Äñ : ‚ÑÇ)  ‚â† 0 := ofReal_inj.mp.mt (norm_ne_zero_iff.mpr hœÜ)
  congr
  field_simp
  ext i j
  fin_cases i <;> fin_cases j <;> field_simp
  ¬∑ rw [‚Üê ofReal_mul, ‚Üê sq, ‚Üê @real_inner_self_eq_norm_sq]
    simp only [PiLp.inner_apply, Complex.inner,  neg_mul, sub_neg_eq_add,
      Fin.sum_univ_two, ofReal_add, ofReal_mul, mul_conj, mul_comm, add_comm]
    rfl
  ¬∑ ring_nf
  ¬∑ ring_nf
  ¬∑ rw [‚Üê ofReal_mul, ‚Üê sq, ‚Üê @real_inner_self_eq_norm_sq]
    simp only [PiLp.inner_apply, Complex.inner,  neg_mul, sub_neg_eq_add,
      Fin.sum_univ_two, ofReal_add, ofReal_mul, mul_conj, mul_comm]
    rfl

lemma rotateMatrix_specialUnitary {œÜ : higgsVec} (hœÜ : œÜ ‚â† 0) :
    (rotateMatrix œÜ) ‚àà specialUnitaryGroup (Fin 2) ‚ÑÇ :=
  mem_specialUnitaryGroup_iff.mpr ‚ü®rotateMatrix_unitary hœÜ, rotateMatrix_det hœÜ‚ü©

/-- Given a Higgs vector, an element of the gauge group which puts the fst component of the
vector to zero, and the snd componenet to a real -/
def rotateGuageGroup {œÜ : higgsVec} (hœÜ : œÜ ‚â† 0) : guageGroup :=
    ‚ü®1, ‚ü®(rotateMatrix œÜ), rotateMatrix_specialUnitary hœÜ‚ü©, 1‚ü©

lemma rotateGuageGroup_apply {œÜ : higgsVec} (hœÜ : œÜ ‚â† 0) :
    rep (rotateGuageGroup hœÜ) œÜ = ![0, ofReal ‚ÄñœÜ‚Äñ] := by
  rw [rep_apply]
  simp [rotateGuageGroup, rotateMatrix]
  ext i
  fin_cases i
  simp [mulVec, vecHead, vecTail]
  ring_nf
  simp only [Fin.mk_one, Fin.isValue, cons_val_one, head_cons]
  simp [mulVec, vecHead, vecTail]
  have : (‚ÄñœÜ‚Äñ : ‚ÑÇ)  ‚â† 0 := ofReal_inj.mp.mt (norm_ne_zero_iff.mpr hœÜ)
  field_simp
  rw [‚Üê ofReal_mul, ‚Üê sq, ‚Üê @real_inner_self_eq_norm_sq]
  simp only [PiLp.inner_apply, Complex.inner,  neg_mul, sub_neg_eq_add,
      Fin.sum_univ_two, ofReal_add, ofReal_mul, mul_conj, mul_comm]
  rfl

theorem rotate_fst_zero_snd_real (œÜ : higgsVec) :
    ‚àÉ (g : guageGroup), rep g œÜ = ![0, ofReal ‚ÄñœÜ‚Äñ] := by
  by_cases h : œÜ = 0
  ¬∑ use ‚ü®1, 1, 1‚ü©
    simp [h]
    ext i
    fin_cases i <;> rfl
  ¬∑ use rotateGuageGroup h
    exact rotateGuageGroup_apply h

end higgsVec
end higgsVec

end
end StandardModel
