/-
Copyright (c) 2024 Joseph Tooby-Smith. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Tooby-Smith
-/
import HepLean.PerturbationTheory.Wick.OperatorMap
/-!

# Contractions of a list of fields

-/

namespace Wick

open HepLean.List
open FieldStatistic

variable {ùìï : Type}

/-- Given a list of fields `œÜs`, the type of pairwise-contractions associated with `œÜs`
  which have the list `œÜs·µ§‚Çô` uncontracted. -/
inductive ContractionsAux : (œÜs : List ùìï) ‚Üí (œÜs·µ§‚Çô : List ùìï) ‚Üí Type
  | nil : ContractionsAux [] []
  | cons {œÜs : List ùìï} {œÜs·µ§‚Çô : List ùìï} {œÜ : ùìï} (i : Option (Fin œÜs·µ§‚Çô.length)) :
    ContractionsAux œÜs œÜs·µ§‚Çô ‚Üí ContractionsAux (œÜ :: œÜs) (optionEraseZ œÜs·µ§‚Çô œÜ i)

/-- Given a list of fields `l`, the type of pairwise-contractions associated with `l`. -/
def Contractions (œÜs : List ùìï) : Type := Œ£ aux, ContractionsAux œÜs aux

namespace Contractions

variable {l : List ùìï} (c : Contractions l)

/-- The list of uncontracted fields. -/
def normalize : List ùìï := c.1

lemma contractions_nil (a : Contractions ([] : List ùìï)) : a = ‚ü®[], ContractionsAux.nil‚ü© := by
  cases a
  rename_i aux c
  cases c
  rfl

def embedUncontracted {l : List ùìï} (c : Contractions l) : Fin c.normalize.length ‚Üí Fin l.length :=
  match l, c with
  | [], ‚ü®[], ContractionsAux.nil‚ü© => Fin.elim0
  | œÜ :: œÜs, ‚ü®_, .cons (œÜs·µ§‚Çô := aux) none c‚ü© =>
    Fin.cons ‚ü®0, Nat.zero_lt_succ œÜs.length‚ü© (Fin.succ ‚àò (embedUncontracted ‚ü®aux, c‚ü©))
  | œÜ :: œÜs, ‚ü®_, .cons (œÜs·µ§‚Çô := aux) (some n) c‚ü© => by
    let lc := embedUncontracted ‚ü®aux, c‚ü©
    refine Fin.succ ‚àò lc ‚àò Fin.cast ?_ ‚àò Fin.succAbove ‚ü®n, by
      rw [normalize, optionEraseZ_some_length]
      omega‚ü©
    simp only [normalize, optionEraseZ_some_length]
    have hq : aux.length ‚â† 0 := by
      by_contra hn
      rw [hn] at n
      exact Fin.elim0 n
    omega

lemma embedUncontracted_injective  {l : List ùìï} (c : Contractions l) :
    Function.Injective c.embedUncontracted := by
  match l, c with
  | [], ‚ü®[], ContractionsAux.nil‚ü© =>
    dsimp [embedUncontracted]
    intro i
    exact Fin.elim0 i
  | œÜ :: œÜs, ‚ü®_, .cons (œÜs·µ§‚Çô := aux) none c‚ü© =>
    dsimp [embedUncontracted]
    refine Fin.cons_injective_iff.mpr ?_
    apply And.intro
    ¬∑ simp only [Set.mem_range, Function.comp_apply, not_exists]
      exact fun x => Fin.succ_ne_zero (embedUncontracted ‚ü®aux, c‚ü© x)
    ¬∑ exact Function.Injective.comp (Fin.succ_injective œÜs.length)
        (embedUncontracted_injective ‚ü®aux, c‚ü©)
  |  œÜ :: œÜs, ‚ü®_, .cons (œÜs·µ§‚Çô := aux) (some i) c‚ü© =>
      dsimp [embedUncontracted]
      refine Function.Injective.comp (Fin.succ_injective œÜs.length) ?hf
      refine Function.Injective.comp (embedUncontracted_injective ‚ü®aux, c‚ü©) ?hf.hf
      refine Function.Injective.comp (Fin.cast_injective (embedUncontracted.proof_5 œÜ œÜs aux i c))
        Fin.succAbove_right_injective



/-- Establishes uniqueness of contractions for a single field, showing that any contraction
  of a single field must be equivalent to the trivial contraction with no pairing. -/
lemma contractions_single {i : ùìï} (a : Contractions [i]) : a =
    ‚ü®[i], ContractionsAux.cons none ContractionsAux.nil‚ü© := by
  cases a
  rename_i aux c
  cases c
  rename_i aux' c'
  cases c'
  cases aux'
  simp only [List.length_nil, optionEraseZ]
  rename_i x
  exact Fin.elim0 x

/--
  This function provides an equivalence between the type of contractions for an empty list of fields
  and the unit type, indicating that there is only one possible contraction for an empty list.
-/
def nilEquiv : Contractions ([] : List ùìï) ‚âÉ Unit where
  toFun _ := ()
  invFun _ := ‚ü®[], ContractionsAux.nil‚ü©
  left_inv a := Eq.symm (contractions_nil a)
  right_inv _ := rfl

/-- The equivalence between contractions of `a :: l` and contractions of
  `Contractions l` paired with an optional element of `Fin (c.normalize).length` specifying
  what `a` contracts with if any. -/
def consEquiv {œÜ : ùìï} {œÜs : List ùìï} :
    Contractions (œÜ :: œÜs) ‚âÉ (c : Contractions œÜs) √ó Option (Fin c.normalize.length) where
  toFun c :=
    match c with
    | ‚ü®aux, c‚ü© =>
    match c with
    | ContractionsAux.cons (œÜs·µ§‚Çô := aux') i c => ‚ü®‚ü®aux', c‚ü©, i‚ü©
  invFun ci :=
    ‚ü®(optionEraseZ (ci.fst.normalize) œÜ ci.2), ContractionsAux.cons (œÜ := œÜ) ci.2 ci.1.2‚ü©
  left_inv c := by
    match c with
    | ‚ü®aux, c‚ü© =>
    match c with
    | ContractionsAux.cons (œÜs·µ§‚Çô := aux') i c => rfl
  right_inv ci := by rfl

lemma consEquiv_ext {œÜs : List ùìï} {c1 c2 : Contractions œÜs}
    {n1 : Option (Fin c1.normalize.length)} {n2 : Option (Fin c2.normalize.length)}
    (hc : c1 = c2) (hn : Option.map (finCongr (by rw [hc])) n1 = n2) :
    (‚ü®c1, n1‚ü© :  (c : Contractions œÜs) √ó Option (Fin c.normalize.length)) = ‚ü®c2, n2‚ü© := by
  subst hc
  subst hn
  simp

/-- The type of contractions is decidable. -/
instance decidable : (œÜs : List ùìï) ‚Üí DecidableEq (Contractions œÜs)
  | [] => fun a b =>
    match a, b with
    | ‚ü®_, a‚ü©, ‚ü®_, b‚ü© =>
    match a, b with
    | ContractionsAux.nil, ContractionsAux.nil => isTrue rfl
  | _ :: œÜs =>
    haveI : DecidableEq (Contractions œÜs) := decidable œÜs
    haveI : DecidableEq ((c : Contractions œÜs) √ó Option (Fin (c.normalize).length)) :=
      Sigma.instDecidableEqSigma
    Equiv.decidableEq consEquiv

/-- The type of contractions is finite. -/
instance fintype : (œÜs : List ùìï) ‚Üí Fintype (Contractions œÜs)
  | [] => {
    elems := {‚ü®[], ContractionsAux.nil‚ü©}
    complete := by
      intro a
      rw [Finset.mem_singleton]
      exact contractions_nil a}
  | œÜ :: œÜs =>
    haveI : Fintype (Contractions œÜs) := fintype œÜs
    haveI : Fintype ((c : Contractions œÜs) √ó Option (Fin (c.normalize).length)) :=
      Sigma.instFintype
    Fintype.ofEquiv _ consEquiv.symm

/-- A contraction is a full contraction if there normalizing list of fields is empty. -/
def IsFull : Prop := c.normalize = []

/-- Provides a decidable instance for determining if a contraction is full
  (i.e., all fields are paired). -/
instance isFull_decidable : Decidable c.IsFull := by
  have hn : c.IsFull ‚Üî c.normalize.length = 0 := by
    simp [IsFull]
  apply decidable_of_decidable_of_iff hn.symm

def toOptionList : {l : List ùìï} ‚Üí  (c : Contractions l)  ‚Üí List (Option (Fin l.length))
  | [], ‚ü®[], ContractionsAux.nil‚ü© => []
  | _ :: _, ‚ü®_, .cons (œÜs·µ§‚Çô := aux) none c‚ü© => none ::
    List.map (Option.map Fin.succ) (toOptionList ‚ü®aux, c‚ü©)
  | _ :: œÜs, ‚ü®_, .cons (œÜs·µ§‚Çô := aux) (some n) c‚ü© =>
    some (Fin.succ (embedUncontracted ‚ü®aux, c‚ü© n)) ::
    List.set ((List.map (Option.map Fin.succ) (toOptionList ‚ü®aux, c‚ü©)))
      (embedUncontracted ‚ü®aux, c‚ü© n) (some ‚ü®0, Nat.zero_lt_succ œÜs.length‚ü©)

lemma toOptionList_length {l : List ùìï} (c : Contractions l) : c.toOptionList.length = l.length := by
  match l, c with
  | [], ‚ü®[], ContractionsAux.nil‚ü© =>
    dsimp [toOptionList]
  | _ :: _, ‚ü®_, .cons (œÜs·µ§‚Çô := aux) none c‚ü© =>
    dsimp [toOptionList]
    rw [List.length_map, toOptionList_length ‚ü®aux, c‚ü©]
  | _ :: œÜs, ‚ü®_, .cons (œÜs·µ§‚Çô := aux) (some n) c‚ü© =>
    dsimp [toOptionList]
    rw [List.length_set, List.length_map, toOptionList_length ‚ü®aux, c‚ü©]

def toFinOptionMap {l : List ùìï} (c : Contractions l) : Fin l.length ‚Üí Option (Fin l.length) :=
  c.toOptionList.get ‚àò Fin.cast (toOptionList_length c).symm

lemma toFinOptionMap_neq_self {l : List ùìï} (c : Contractions l) (i : Fin l.length) :
    c.toFinOptionMap i ‚â† some i := by
  match l, c with
  | [], ‚ü®[], ContractionsAux.nil‚ü© =>
    exact Fin.elim0 i
  | _ :: _, ‚ü®_, .cons (œÜs·µ§‚Çô := aux) none c‚ü© =>
    dsimp [toFinOptionMap, toOptionList]
    match i with
    | ‚ü®0, _‚ü© =>
      exact Option.noConfusion
    | ‚ü®n + 1, h‚ü© =>
      simp only [List.getElem_cons_succ, List.getElem_map, List.length_cons]
      have hn := toFinOptionMap_neq_self ‚ü®aux, c‚ü© ‚ü®n, Nat.succ_lt_succ_iff.mp h‚ü©
      simp only [Option.map_eq_some', not_exists, not_and]
      intro x hx
      simp only [toFinOptionMap, Function.comp_apply, Fin.cast_mk, List.get_eq_getElem, hx, ne_eq,
        Option.some.injEq] at hn
      rw [Fin.ext_iff] at hn ‚ä¢
      simp_all
  | _ :: œÜs, ‚ü®_, .cons (œÜs·µ§‚Çô := aux) (some n) c‚ü© =>
    dsimp [toFinOptionMap, toOptionList]
    match i with
    | ‚ü®0, _‚ü© =>
      simp only [List.getElem_cons_zero, List.length_cons, Fin.zero_eta, Option.some.injEq, ne_eq]
      exact Fin.succ_ne_zero (embedUncontracted ‚ü®aux, c‚ü© n)
    | ‚ü®n + 1, h‚ü© =>
      simp only [List.getElem_cons_succ, List.length_cons, ne_eq]
      rw [List.getElem_set]
      split
      ¬∑ exact ne_of_beq_false rfl
      ¬∑ simp only [List.getElem_map, Option.map_eq_some', not_exists, not_and]
        intro x hx
        have hn := toFinOptionMap_neq_self ‚ü®aux, c‚ü© ‚ü®n, Nat.succ_lt_succ_iff.mp h‚ü©
        simp only [toFinOptionMap, Function.comp_apply, Fin.cast_mk, List.get_eq_getElem, hx, ne_eq,
          Option.some.injEq] at hn
        rw [Fin.ext_iff] at hn ‚ä¢
        simp_all

@[simp]
lemma toFinOptionMap_embedUncontracted {l : List ùìï} (c : Contractions l)
    (i : Fin c.normalize.length) : c.toFinOptionMap (embedUncontracted c i) = none := by
  match l, c with
  | [], ‚ü®[], ContractionsAux.nil‚ü© =>
    exact Fin.elim0 i
  | _ :: _, ‚ü®_, .cons (œÜs·µ§‚Çô := aux) none c‚ü© =>
    dsimp [toFinOptionMap, toOptionList, embedUncontracted]
    match i with
    | ‚ü®0, _‚ü© =>
      rfl
    | ‚ü®n + 1, h‚ü© =>
      rw [show ‚ü®n + 1, h‚ü© = Fin.succ ‚ü®n,  Nat.succ_lt_succ_iff.mp h‚ü© by rfl]
      rw [Fin.cons_succ]
      simp only [Function.comp_apply, Fin.val_succ, List.getElem_cons_succ, List.getElem_map,
        Option.map_eq_none']
      exact toFinOptionMap_embedUncontracted ‚ü®aux, c‚ü© ‚ü®n, Nat.succ_lt_succ_iff.mp h‚ü©
  | _ :: œÜs, ‚ü®_, .cons (œÜs·µ§‚Çô := aux) (some n) c‚ü© =>
    dsimp [toFinOptionMap, toOptionList, embedUncontracted]
    rw [List.getElem_set]
    split
    ¬∑ rename_i hs
      have hx := embedUncontracted_injective ‚ü®aux, c‚ü© (Fin.val_injective hs)
      refine False.elim ?_
      have hn := Fin.succAbove_ne ‚ü®n, embedUncontracted.proof_6 _ œÜs aux n c‚ü© i
      simp [Fin.ext_iff] at hx
      simp [Fin.ext_iff] at hn
      exact hn (id (Eq.symm hx))
    ¬∑ simp
      exact toFinOptionMap_embedUncontracted ‚ü®aux, c‚ü© _

lemma toFinOptionMap_involutive {l : List ùìï} (c : Contractions l) (i j : Fin l.length) :
    c.toFinOptionMap i = some j ‚Üí c.toFinOptionMap j = some i := by
  match l, c with
  | [], ‚ü®[], ContractionsAux.nil‚ü© =>
    exact Fin.elim0 i
  | _ :: _, ‚ü®_, .cons (œÜs·µ§‚Çô := aux) none c‚ü© =>
    dsimp [toFinOptionMap, toOptionList]
    match i, j with
    | ‚ü®0, _‚ü©, j =>
      exact Option.noConfusion
    | ‚ü®n + 1, h‚ü©, ‚ü®0, _‚ü© =>
      simp
      intro x hx
      exact Fin.succ_ne_zero x
    | ‚ü®n + 1, hn‚ü©, ‚ü®m + 1, hm‚ü© =>
      intro h1
      have hnm := toFinOptionMap_involutive ‚ü®aux, c‚ü© ‚ü®n, Nat.succ_lt_succ_iff.mp hn‚ü©
        ‚ü®m, Nat.succ_lt_succ_iff.mp hm‚ü©
      simp
      simp [toFinOptionMap] at hnm
      have hnm' := hnm (by
        simp at h1
        obtain ‚ü®a, ha, ha2‚ü© := h1
        rw [ha]
        simp only [Option.some.injEq]
        rw [Fin.ext_iff] at ha2 ‚ä¢
        simp_all)
      use ‚ü®n, Nat.succ_lt_succ_iff.mp hn‚ü©
      simpa using hnm'
  | _ :: œÜs, ‚ü®_, .cons (œÜs·µ§‚Çô := aux) (some n) c‚ü© =>
    dsimp [toFinOptionMap, toOptionList]
    match i, j with
    | ‚ü®0, _‚ü©, j =>
      intro hj
      simp only [List.getElem_cons_zero, Option.some.injEq] at hj
      subst hj
      simp
    | ‚ü®n' + 1, h‚ü©, ‚ü®0, _‚ü© =>
      intro hj
      simp at hj
      simp
      rw [List.getElem_set] at hj
      simp_all only [List.length_cons, lt_add_iff_pos_left, add_pos_iff, zero_lt_one, or_true, List.getElem_map,
        ite_eq_left_iff, Option.map_eq_some']
      simp [Fin.ext_iff]
      by_contra hn
      have hn' := hj hn
      obtain ‚ü®a, ha, ha2‚ü© := hn'
      exact Fin.succ_ne_zero a ha2
    | ‚ü®n' + 1, hn‚ü©, ‚ü®m + 1, hm‚ü© =>
      simp
      rw [List.getElem_set, List.getElem_set]
      simp
      split
      ¬∑ intro h
        simp [Fin.ext_iff] at h
      rename_i hn'
      intro h1
      split
      ¬∑ rename_i hnx
        have hnm := toFinOptionMap_involutive ‚ü®aux, c‚ü© ‚ü®n', Nat.succ_lt_succ_iff.mp hn‚ü©
          ‚ü®m, Nat.succ_lt_succ_iff.mp hm‚ü©
        subst hnx
        simp at hnm
        refine False.elim (hnm ?_)
        simp at h1
        obtain ‚ü®a, ha, ha2‚ü© := h1
        have ha' : (embedUncontracted ‚ü®aux, c‚ü© n) = a := by
          rw [Fin.ext_iff] at ha2 ‚ä¢
          simp_all
        rw [ha']
        rw [‚Üê ha]
        rfl
      ¬∑ rename_i hnx
        have hnm := toFinOptionMap_involutive ‚ü®aux, c‚ü© ‚ü®n', Nat.succ_lt_succ_iff.mp hn‚ü©
          ‚ü®m, Nat.succ_lt_succ_iff.mp hm‚ü© (by
          dsimp [toFinOptionMap]
          simp at h1
          obtain ‚ü®a, ha, ha2‚ü© := h1
          have ha' : a = ‚ü®m, by exact Nat.succ_lt_succ_iff.mp hm‚ü© := by
            rw [Fin.ext_iff] at ha2 ‚ä¢
            simp_all
          rw [‚Üê ha', ‚Üê ha])
        change Option.map Fin.succ (toFinOptionMap ‚ü®aux, c‚ü© ‚ü®m, Nat.succ_lt_succ_iff.mp hm‚ü©)  = _
        rw [hnm]
        rfl

def toInvolution {l : List ùìï} (c : Contractions l) : Fin l.length ‚Üí Fin l.length :=
  fun i =>
  if h : Option.isSome (c.toFinOptionMap i) then Option.get (c.toFinOptionMap i) h else i

lemma toInvolution_of_isSome {l : List ùìï} {c : Contractions l} {i : Fin l.length}
    (hs : Option.isSome (c.toFinOptionMap i)) :
    c.toInvolution i = Option.get (c.toFinOptionMap i) hs := by
  dsimp [toInvolution]
  rw [dif_pos hs]

lemma toInvolution_of_eq_none {l : List ùìï} {c : Contractions l} {i : Fin l.length}
    (hs : (c.toFinOptionMap i) = none) :
    c.toInvolution i = i := by
  dsimp [toInvolution]
  rw [dif_neg]
  simp_all

lemma toInvolution_image_isSome {l : List ùìï} {c : Contractions l} {i : Fin l.length}
    (hs : Option.isSome (c.toFinOptionMap i)) :
    Option.isSome (c.toFinOptionMap (c.toInvolution i)) := by
  dsimp [toInvolution]
  rw [dif_pos hs]
  have hx := toFinOptionMap_involutive c i ((c.toFinOptionMap i).get hs)
  simp at hx
  rw [hx]
  rfl

lemma toInvolution_involutive {l : List ùìï} (c : Contractions l) :
    Function.Involutive c.toInvolution := by
  intro i
  by_cases h : Option.isSome (c.toFinOptionMap i)
  ¬∑ have hx := toFinOptionMap_involutive c i ((c.toFinOptionMap i).get h)
    rw [toInvolution_of_isSome (toInvolution_image_isSome h)]
    simp only [Option.some_get, forall_const] at hx
    simp only [toInvolution_of_isSome h, hx, Option.get_some]
  ¬∑ simp at h
    rw [toInvolution_of_eq_none h]
    rw [toInvolution_of_eq_none h]

def involutionEquiv1 {l : List ùìï} :
    {f : Fin l.length ‚Üí Fin l.length // Function.Involutive f } ‚âÉ
    {f : Fin l.length ‚Üí Option (Fin l.length) // (‚àÄ i, f i ‚â† some i) ‚àß
    ‚àÄ i j, f i = some j ‚Üí f j = some i} where
  toFun f := ‚ü®fun i => if h : f.1 i = i then none else f.1 i,
    fun i => by
      simp,
    fun i j => by
      simp
      intro hi hij
      subst hij
      rw [f.2]
      simp
      exact fun a => hi (id (Eq.symm a))‚ü©
  invFun f := ‚ü®fun i => if h : (f.1 i).isSome then Option.get (f.1 i) h  else i,
    fun i => by
    by_cases h : Option.isSome (f.1 i)
    ¬∑ simp [h]
      have hf := f.2.2 i (Option.get (f.1 i) h) (by simp)
      simp [hf]
    ¬∑ simp
      rw [dif_neg]
      ¬∑ rw [dif_neg h]
      ¬∑ rw [dif_neg h]
        exact h‚ü©
  left_inv f := by
    simp
    ext i
    simp
    by_cases hf : f.1 i = i
    ¬∑ simp [hf]
    ¬∑ simp [hf]
  right_inv f := by
    simp
    ext1
    simp
    funext i
    obtain ‚ü®val, property‚ü© := f
    obtain ‚ü®left, right‚ü© := property
    simp_all only [ne_eq]
    split
    next h =>
      ext a : 1
      simp_all only [Option.mem_def, reduceCtorEq, false_iff]
      apply Aesop.BuiltinRules.not_intro
      intro a_1
      simp_all only [Option.isSome_some, Option.get_some, forall_const]
    next h =>
      simp_all only [not_forall]
      obtain ‚ü®w, h‚ü© := h
      simp_all only [‚ÜìreduceDIte, Option.some_get]

def involutionCons (n : ‚Ñï):
    {f : Fin n.succ ‚Üí Fin n.succ // Function.Involutive f } ‚âÉ
    (f : {f : Fin n ‚Üí Fin n // Function.Involutive f}) √ó {i : Option (Fin n) //
      ‚àÄ (h : i.isSome), f.1 (Option.get i h) = (Option.get i h)} where
  toFun f := ‚ü®‚ü®
    fun i =>
    if h : f.1 i.succ = 0 then i
    else Fin.pred (f.1 i.succ) h , by
    intro i
    by_cases h : f.1 i.succ = 0
    ¬∑ simp [h]
    ¬∑ simp [h]
      simp [f.2 i.succ]
      intro h
      exact False.elim (Fin.succ_ne_zero i h)‚ü©,
    ‚ü®if h : f.1 0 = 0 then none else Fin.pred (f.1 0) h , by
    by_cases h0 : f.1 0 = 0
    ¬∑ simp [h0]
    ¬∑ simp [h0]
      refine fun h => False.elim (h (f.2 0))‚ü©‚ü©
  invFun f := ‚ü®
      if h : (f.2.1).isSome then
        Fin.cons (f.2.1.get h).succ (Function.update (Fin.succ ‚àò f.1.1) (f.2.1.get h) 0)
      else
        Fin.cons 0 (Fin.succ ‚àò f.1.1)
    , by
    by_cases hs : (f.2.1).isSome
    ¬∑ simp only [Nat.succ_eq_add_one, hs, ‚ÜìreduceDIte, Fin.coe_eq_castSucc]
      let a := f.2.1.get hs
      change Function.Involutive (Fin.cons a.succ (Function.update (Fin.succ ‚àò ‚Üëf.fst) a 0))
      intro i
      rcases Fin.eq_zero_or_eq_succ i with hi | ‚ü®j, hj‚ü©
      ¬∑ subst hi
        rw [Fin.cons_zero, Fin.cons_succ]
        simp
      ¬∑ subst hj
        rw [Fin.cons_succ]
        by_cases hja : j = a
        ¬∑ subst hja
          simp
        ¬∑ rw [Function.update_apply ]
          rw [if_neg hja]
          simp
          have hf2 := f.2.2 hs
          change f.1.1 a = a at hf2
          have hjf1 : f.1.1 j ‚â† a := by
            by_contra hn
            have haj : j = f.1.1 a := by
              rw [‚Üê hn]
              rw [f.1.2]
            rw [hf2] at haj
            exact hja haj
          rw [Function.update_apply, if_neg hjf1]
          simp
          rw [f.1.2]
    ¬∑ simp [hs]
      intro i
      rcases Fin.eq_zero_or_eq_succ i with hi | ‚ü®j, hj‚ü©
      ¬∑ subst hi
        simp
      ¬∑ subst hj
        simp
        rw [f.1.2]‚ü©
  left_inv f := by
    match f with
    | ‚ü®f, hf‚ü© =>
    simp
    ext i
    by_cases h0 : f 0 = 0
    ¬∑ simp [h0]
      rcases Fin.eq_zero_or_eq_succ i with hi | ‚ü®j, hj‚ü©
      ¬∑ subst hi
        simp [h0]
      ¬∑ subst hj
        simp [h0]
        by_cases hj : f j.succ =0
        ¬∑ rw [‚Üê h0] at hj
          have hn := Function.Involutive.injective hf hj
          exact False.elim (Fin.succ_ne_zero j hn)
        ¬∑ simp [hj]
          rw [Fin.ext_iff] at hj
          simp at hj
          omega
    ¬∑ rw [if_neg h0]
      by_cases hf' : i = f 0
      ¬∑ subst hf'
        simp
        rw [hf]
        simp
      ¬∑ rw [Function.update_apply, if_neg hf']
        rcases Fin.eq_zero_or_eq_succ i with hi | ‚ü®j, hj‚ü©
        ¬∑ subst hi
          simp
        ¬∑ subst hj
          simp
          by_cases hj : f j.succ =0
          ¬∑ rw [‚Üê hj] at hf'
            rw [hf] at hf'
            simp at hf'
          ¬∑ simp [hj]
            rw [Fin.ext_iff] at hj
            simp at hj
            omega
  right_inv f := by
    match f with
    | ‚ü®‚ü®f, hf‚ü©, ‚ü®f0, hf0‚ü©‚ü© =>
    ext i
    ¬∑ simp
      by_cases hs : f0.isSome
      ¬∑ simp [hs]
        by_cases hi : i = f0.get hs
        ¬∑ simp [hi, Function.update_apply]
          exact Eq.symm (Fin.val_eq_of_eq (hf0 hs))
        ¬∑ simp [hi]
          split
          ¬∑ rename_i h
            exact False.elim (Fin.succ_ne_zero (f i) h)
          ¬∑ rfl
      ¬∑ simp [hs]
        split
        ¬∑ rename_i h
          exact False.elim (Fin.succ_ne_zero (f i) h)
        ¬∑ rfl
    ¬∑ simp only [Nat.succ_eq_add_one,  Option.mem_def,
      Option.dite_none_left_eq_some, Option.some.injEq]
      by_cases hs : f0.isSome
      ¬∑ simp only [hs, ‚ÜìreduceDIte]
        simp [Fin.cons_zero]
        have hx : ¬¨  (f0.get hs).succ = 0 :=  (Fin.succ_ne_zero (f0.get hs))
        simp [hx]
        refine Iff.intro (fun hi => ?_) (fun hi => ?_)
        ¬∑ rw [‚Üê hi]
          exact
            Option.eq_some_of_isSome
              (Eq.mpr_prop (Eq.refl (f0.isSome = true))
                (of_eq_true (Eq.trans (congrArg (fun x => x = true) hs) (eq_self true))))
        ¬∑ subst hi
          exact rfl
      ¬∑ simp [hs]
        simp at hs
        subst hs
        exact ne_of_beq_false rfl

lemma involutionCons_ext {n : ‚Ñï} {f1 f2 :  (f : {f : Fin n ‚Üí Fin n // Function.Involutive f}) √ó {i : Option (Fin n) // ‚àÄ (h : i.isSome), f.1 (Option.get i h) = (Option.get i h)}}
    (h1 : f1.1 = f2.1) (h2 : f1.2 = Equiv.subtypeEquivRight (by rw [h1]; simp) f2.2) : f1 = f2 := by
  cases f1
  cases f2
  simp at h1 h2
  subst h1
  rename_i fst snd snd_1
  simp_all only [Sigma.mk.inj_iff, heq_eq_eq, true_and]
  obtain ‚ü®val, property‚ü© := fst
  obtain ‚ü®val_1, property_1‚ü© := snd
  obtain ‚ü®val_2, property_2‚ü© := snd_1
  simp_all only
  rfl

def uncontractedEquiv' {l : List ùìï} (f : {f : Fin l.length ‚Üí Fin l.length // Function.Involutive f}) :
    {i : Option (Fin l.length) //
        ‚àÄ (h : i.isSome), f.1 (Option.get i h) = (Option.get i h)} ‚âÉ
    Option (Fin (Finset.univ.filter fun i => f.1 i = i).card)  := by
  let e1 : {i : Option (Fin l.length) // ‚àÄ (h : i.isSome), f.1 (Option.get i h) = (Option.get i h)}
        ‚âÉ Option {i : Fin l.length // f.1 i = i} :=
    { toFun := fun i => match i with
        | ‚ü®some i, h‚ü© => some ‚ü®i, by simpa using h‚ü©
        | ‚ü®none, h‚ü© => none
      invFun := fun i => match i with
        | some ‚ü®i, h‚ü© => ‚ü®some i, by simpa using h‚ü©
        | none => ‚ü®none, by simp‚ü©
      left_inv := by
        intro a
        cases a
        aesop
      right_inv := by
        intro a
        cases a
        rfl
        simp_all only [Subtype.coe_eta] }
  let s : Finset (Fin l.length) := Finset.univ.filter fun i => f.1 i = i
  let e2' : { i : Fin l.length // f.1 i = i} ‚âÉ {i // i ‚àà s} := by
    refine Equiv.subtypeEquivProp ?h
    funext i
    simp [s]
  let e2 : {i // i ‚àà s} ‚âÉ Fin (Finset.card s) := by
     refine (Finset.orderIsoOfFin _ ?_).symm.toEquiv
     simp [s]
  refine e1.trans (Equiv.optionCongr (e2'.trans (e2)))


lemma uncontractedEquiv'_none_image_zero {œÜs : List ùìï}  {œÜ :  ùìï} :
    {f : {f : Fin (œÜ :: œÜs).length ‚Üí Fin (œÜ :: œÜs).length // Function.Involutive f}}
    ‚Üí uncontractedEquiv' (involutionCons œÜs.length f).1 (involutionCons œÜs.length f).2  = none
    ‚Üí f.1 ‚ü®0, Nat.zero_lt_succ œÜs.length‚ü© = ‚ü®0, Nat.zero_lt_succ œÜs.length‚ü© := by
  intro f h
  simp only [Nat.succ_eq_add_one, involutionCons, Equiv.coe_fn_mk, uncontractedEquiv',
    Option.isSome_some, Option.get_some, Option.isSome_none, Equiv.trans_apply,
    Equiv.optionCongr_apply, Equiv.coe_trans, RelIso.coe_fn_toEquiv, Option.map_eq_none'] at h
  simp_all only [List.length_cons, Fin.zero_eta]
  obtain ‚ü®val, property‚ü© := f
  simp_all only [List.length_cons]
  split at h
  next i i_1 h_1 heq =>
    split at heq
    next h_2 => simp_all only [reduceCtorEq]
    next h_2 => simp_all only [reduceCtorEq]
  next i h_1 heq =>
    split at heq
    next h_2 => simp_all only
    next h_2 => simp_all only [Subtype.mk.injEq, reduceCtorEq]

lemma uncontractedEquiv'_cast {l : List ùìï} {f1 f2 : {f : Fin l.length ‚Üí Fin l.length // Function.Involutive f}}
    (hf : f1 = f2):
    uncontractedEquiv' f1 =  (Equiv.subtypeEquivRight  (by rw [hf]; simp)).trans
      ((uncontractedEquiv' f2).trans (Equiv.optionCongr (finCongr (by rw [hf])))):= by
  subst hf
  simp
  rfl

lemma uncontractedEquiv'_none_succ {œÜs : List ùìï}  {œÜ :  ùìï} :
    {f : {f : Fin (œÜ :: œÜs).length ‚Üí Fin (œÜ :: œÜs).length // Function.Involutive f}}
    ‚Üí uncontractedEquiv' (involutionCons œÜs.length f).1 (involutionCons œÜs.length f).2  = none
    ‚Üí ‚àÄ (x : Fin œÜs.length), f.1 x.succ  = x.succ ‚Üî (involutionCons œÜs.length f).1.1 x = x := by
  intro f h x
  simp [involutionCons]
  have hn' := uncontractedEquiv'_none_image_zero h
  have hx : ¬¨ f.1 x.succ = ‚ü®0,  Nat.zero_lt_succ œÜs.length‚ü©:= by
    rw [‚Üê hn']
    exact fun hn => Fin.succ_ne_zero x (Function.Involutive.injective f.2 hn)
  apply Iff.intro
  ¬∑ intro h2 h3
    rw [Fin.ext_iff]
    simp [h2]
  ¬∑ intro h2
    have h2' := h2 hx
    conv_rhs => rw [‚Üê h2']
    simp


lemma uncontractedEquiv'_isSome_image_zero {œÜs : List ùìï}  {œÜ :  ùìï} :
    {f : {f : Fin (œÜ :: œÜs).length ‚Üí Fin (œÜ :: œÜs).length // Function.Involutive f}}
    ‚Üí (uncontractedEquiv' (involutionCons œÜs.length f).1 (involutionCons œÜs.length f).2).isSome
    ‚Üí ¬¨ f.1 ‚ü®0, Nat.zero_lt_succ œÜs.length‚ü© = ‚ü®0, Nat.zero_lt_succ œÜs.length‚ü© := by
  intro f hf
  simp [uncontractedEquiv', involutionCons] at hf
  simp_all only [List.length_cons, Fin.zero_eta]
  obtain ‚ü®val, property‚ü© := f
  simp_all only [List.length_cons]
  apply Aesop.BuiltinRules.not_intro
  intro a
  simp_all only [‚ÜìreduceDIte, Option.isSome_none, Bool.false_eq_true]



def uncontractedFromInvolution:  {œÜs : List ùìï} ‚Üí
    (f : {f : Fin œÜs.length ‚Üí Fin œÜs.length // Function.Involutive f}) ‚Üí
    {l : List ùìï // l.length = (Finset.univ.filter fun i => f.1 i = i).card}
  | [], _ => ‚ü®[], by simp‚ü©
  | œÜ :: œÜs, f =>
    let luc := uncontractedFromInvolution (involutionCons œÜs.length f).fst
    let n' := uncontractedEquiv' (involutionCons œÜs.length f).1 (involutionCons œÜs.length f).2
    if  hn : n' = none then
      have hn' := uncontractedEquiv'_none_image_zero (œÜs := œÜs) (œÜ := œÜ) (f := f) hn
      ‚ü®optionEraseZ luc œÜ none, by
        simp [optionEraseZ]
        rw [‚Üê luc.2]
        conv_rhs => rw [Finset.card_filter]
        rw [Fin.sum_univ_succ]
        conv_rhs => erw [if_pos hn']
        ring_nf
        simp only [Nat.succ_eq_add_one, Mathlib.Vector.length_val,  Nat.cast_id,
          add_right_inj]
        rw [Finset.card_filter]
        apply congrArg
        funext i
        refine ite_congr ?h.h.h‚ÇÅ (congrFun rfl) (congrFun rfl)
        rw [uncontractedEquiv'_none_succ hn]‚ü©
    else
      let n := n'.get (Option.isSome_iff_ne_none.mpr hn)
      let np : Fin luc.1.length := ‚ü®n.1, by
        rw [luc.2]
        exact n.prop‚ü©
      ‚ü®optionEraseZ luc œÜ (some np), by
      let k' := (involutionCons œÜs.length f).2
      have hkIsSome : (k'.1).isSome := by
        simp [n', uncontractedEquiv' ] at hn
        split at hn
        ¬∑ simp_all only [reduceCtorEq, not_false_eq_true, Nat.succ_eq_add_one, Option.isSome_some, k']
        ¬∑ simp_all only [not_true_eq_false]
      let k := k'.1.get hkIsSome
      rw [optionEraseZ_some_length]
      have hksucc : k.succ = f.1 ‚ü®0, Nat.zero_lt_succ œÜs.length‚ü© := by
        simp [k, k', involutionCons]
      have hzero : ‚ü®0, Nat.zero_lt_succ œÜs.length‚ü©  = f.1 k.succ := by
        rw [hksucc]
        rw [f.2]
      have hkcons : ((involutionCons œÜs.length) f).1.1 k = k := by
        exact k'.2 hkIsSome
      have hksuccNe : f.1 k.succ ‚â† k.succ := by
        conv_rhs => rw [hksucc]
        exact fun hn => Fin.succ_ne_zero k (Function.Involutive.injective f.2 hn )
      have hluc : 1 ‚â§ luc.1.length := by
        simp
        use k
        simp [involutionCons]
        rw [hksucc, f.2]
        simp
      rw [propext (Nat.sub_eq_iff_eq_add' hluc)]
      have h0 : ¬¨  f.1 ‚ü®0, Nat.zero_lt_succ œÜs.length‚ü© = ‚ü®0, Nat.zero_lt_succ œÜs.length‚ü© := by
        exact Option.isSome_dite'.mp hkIsSome
      conv_rhs =>
        rw [Finset.card_filter]
        erw [Fin.sum_univ_succ]
        erw [if_neg h0]
      simp only [Nat.succ_eq_add_one, Mathlib.Vector.length_val, List.length_cons,
        Nat.cast_id, zero_add]
      conv_rhs => lhs; rw [Eq.symm (Fintype.sum_ite_eq' k fun j => 1)]
      rw [‚Üê Finset.sum_add_distrib]
      rw [Finset.card_filter]
      apply congrArg
      funext i
      by_cases hik : i = k
      ¬∑ subst hik
        simp [hkcons, hksuccNe]
      ¬∑ simp [hik]
        refine ite_congr ?_ (congrFun rfl) (congrFun rfl)
        simp [involutionCons]
        have hfi : f.1 i.succ ‚â† ‚ü®0, Nat.zero_lt_succ œÜs.length‚ü© := by
          rw [hzero]
          by_contra hn
          have hik' := (Function.Involutive.injective f.2 hn)
          simp only [List.length_cons, Fin.succ_inj] at hik'
          exact hik hik'
        apply Iff.intro
        ¬∑ intro h
          have h' := h hfi
          conv_rhs => rw [‚Üê h']
          simp
        ¬∑ intro h hfi
          simp [Fin.ext_iff]
          rw [h]
          simp‚ü©

lemma uncontractedFromInvolution_cons {œÜs : List ùìï} {œÜ : ùìï}
    (f : {f : Fin (œÜ :: œÜs).length ‚Üí Fin (œÜ :: œÜs).length // Function.Involutive f}) :
    uncontractedFromInvolution f =
    optionEraseZ (uncontractedFromInvolution (involutionCons œÜs.length f).fst) œÜ
    (Option.map (finCongr ((uncontractedFromInvolution (involutionCons œÜs.length f).fst).2.symm))
    (uncontractedEquiv' (involutionCons œÜs.length f).1 (involutionCons œÜs.length f).2)) := by
  let luc := uncontractedFromInvolution (involutionCons œÜs.length f).fst
  let n' := uncontractedEquiv' (involutionCons œÜs.length f).1 (involutionCons œÜs.length f).2
  change _ = optionEraseZ luc œÜ
    (Option.map (finCongr ((uncontractedFromInvolution (involutionCons œÜs.length f).fst).2.symm)) n')
  dsimp [uncontractedFromInvolution]
  by_cases hn : n' = none
  ¬∑ have hn' := hn
    simp [n'] at hn'
    simp [hn']
    rw [hn]
    rfl
  ¬∑ have hn' := hn
    simp [n'] at hn'
    simp [hn']
    congr
    simp [n']
    simp_all only [Nat.succ_eq_add_one, not_false_eq_true, n', luc]
    obtain ‚ü®val, property‚ü© := f
    obtain ‚ü®val_1, property_1‚ü© := luc
    simp_all only [Nat.succ_eq_add_one, List.length_cons]
    ext a : 1
    simp_all only [Option.mem_def, Option.some.injEq, Option.map_eq_some', finCongr_apply]
    apply Iff.intro
    ¬∑ intro a_1
      subst a_1
      apply Exists.intro
      ¬∑ apply And.intro
        on_goal 2 => {rfl
        }
        ¬∑ simp_all only [Option.some_get]
    ¬∑ intro a_1
      obtain ‚ü®w, h‚ü© := a_1
      obtain ‚ü®left, right‚ü© := h
      subst right
      simp_all only [Option.get_some]
      rfl

def auxCongr  : {œÜs: List ùìï} ‚Üí  {œÜs·µ§‚Çô œÜs·µ§‚Çô' : List ùìï} ‚Üí (h : œÜs·µ§‚Çô = œÜs·µ§‚Çô') ‚Üí
    ContractionsAux œÜs œÜs·µ§‚Çô ‚âÉ ContractionsAux œÜs œÜs·µ§‚Çô'
  | _, _, _, Eq.refl _ => Equiv.refl _

lemma auxCongr_ext {œÜs: List ùìï} {c c2 : Contractions œÜs} (h : c.1 = c2.1)
    (hx : c.2 =  auxCongr h.symm c2.2) : c = c2 := by
  cases c
  cases c2
  simp at h
  subst h
  simp [auxCongr] at hx
  subst hx
  rfl


lemma uncontractedEquiv'_cast' {l : List ùìï} {f1 f2 : {f : Fin l.length ‚Üí Fin l.length // Function.Involutive f}}
  {N : ‚Ñï} (hf : f1 = f2) (n : Option (Fin N)) (hn1 : N = (Finset.filter (fun i => f1.1 i = i) Finset.univ).card)
  (hn2 : N = (Finset.filter (fun i => f2.1 i = i) Finset.univ).card):
    HEq ((uncontractedEquiv' f1).symm (Option.map (finCongr hn1) n)) ((uncontractedEquiv' f2).symm (Option.map (finCongr hn2) n)) := by
  subst hf
  rfl

def toInvolution'  : {œÜs : List ùìï} ‚Üí  (c : Contractions œÜs) ‚Üí
    {f : {f : Fin œÜs.length ‚Üí Fin œÜs.length // Function.Involutive f} //
    uncontractedFromInvolution f = c.1}
  | [], ‚ü®[], ContractionsAux.nil‚ü© => ‚ü®‚ü®fun i => i, by
    intro i
    simp‚ü©, by rfl‚ü©
  | œÜ :: œÜs, ‚ü®_, .cons (œÜs·µ§‚Çô := aux) n c‚ü© => by
    let ‚ü®‚ü®f', hf1‚ü©, hf2‚ü© := toInvolution' ‚ü®aux, c‚ü©
    let n' : Option (Fin (uncontractedFromInvolution ‚ü®f', hf1‚ü©).1.length) :=
      Option.map (finCongr (by rw [hf2])) n
    let F := (involutionCons œÜs.length).symm ‚ü®‚ü®f', hf1‚ü©,
       (uncontractedEquiv' ‚ü®f', hf1‚ü©).symm
       (Option.map (finCongr ((uncontractedFromInvolution ‚ü®f', hf1‚ü©).2))  n')‚ü©
    refine ‚ü®F, ?_‚ü©
    have hF0 : ((involutionCons œÜs.length) F) = ‚ü®‚ü®f', hf1‚ü©,
       (uncontractedEquiv'  ‚ü®f', hf1‚ü©).symm
       (Option.map (finCongr ((uncontractedFromInvolution ‚ü®f', hf1‚ü©).2))  n')‚ü© := by
      simp [F]
    have hF1 : ((involutionCons œÜs.length) F).fst = ‚ü®f', hf1‚ü© := by
      rw [hF0]
    have hF2L : ((uncontractedFromInvolution ‚ü®f', hf1‚ü©)).1.length =
      (Finset.filter (fun i => ((involutionCons œÜs.length) F).1.1 i = i) Finset.univ).card := by
      apply  Eq.trans ((uncontractedFromInvolution ‚ü®f', hf1‚ü©)).2
      congr
      rw [hF1]
    have hF2 : ((involutionCons œÜs.length) F).snd = (uncontractedEquiv' ((involutionCons œÜs.length) F).fst).symm
      (Option.map (finCongr hF2L) n') := by
      rw [@Sigma.subtype_ext_iff] at hF0
      ext1
      rw [hF0.2]
      simp
      congr 1
      ¬∑ rw [hF1]
      ¬∑ refine uncontractedEquiv'_cast' ?_ n' _ _
        rw [hF1]
    rw [uncontractedFromInvolution_cons]
    have hx := (toInvolution' ‚ü®aux, c‚ü©).2
    simp at hx
    simp
    refine optionEraseZ_ext ?_ ?_ ?_
    ¬∑ dsimp [F]
      rw [Equiv.apply_symm_apply]
      simp
      rw [‚Üê hx]
      simp_all only
    ¬∑ rfl
    ¬∑ simp [hF2]
      dsimp [n']
      simp [finCongr]
      simp only [Nat.succ_eq_add_one, id_eq, eq_mpr_eq_cast, F, n']
      ext a : 1
      simp only [Option.mem_def, Option.map_eq_some', Function.comp_apply, Fin.cast_trans,
        Fin.cast_eq_self, exists_eq_right]

lemma toInvolution'_length {œÜs œÜs·µ§‚Çô : List ùìï} {c : ContractionsAux œÜs œÜs·µ§‚Çô} :
    œÜs·µ§‚Çô.length = (Finset.filter (fun i => (toInvolution' ‚ü®œÜs·µ§‚Çô, c‚ü©).1.1 i = i) Finset.univ).card
     := by
  have h2 := (toInvolution' ‚ü®œÜs·µ§‚Çô, c‚ü©).2
  simp at h2
  conv_lhs => rw [‚Üê h2]
  exact Mathlib.Vector.length_val (uncontractedFromInvolution (toInvolution' ‚ü®œÜs·µ§‚Çô, c‚ü©).1)

lemma toInvolution'_cons {œÜs œÜs·µ§‚Çô : List ùìï} {œÜ : ùìï}
    (c : ContractionsAux œÜs œÜs·µ§‚Çô) (n : Option (Fin (œÜs·µ§‚Çô.length))) :
    (toInvolution' ‚ü®optionEraseZ œÜs·µ§‚Çô œÜ n, ContractionsAux.cons n c‚ü©).1
    = (involutionCons œÜs.length).symm ‚ü®(toInvolution' ‚ü®œÜs·µ§‚Çô, c‚ü©).1,
      (uncontractedEquiv' (toInvolution' ‚ü®œÜs·µ§‚Çô, c‚ü©).1).symm
      (Option.map (finCongr (toInvolution'_length)) n)‚ü© := by
  dsimp [toInvolution']
  congr 3
  rw [Option.map_map]
  simp [finCongr]
  rfl

lemma toInvolution_consEquiv {œÜs : List ùìï} {œÜ : ùìï}
    (c : Contractions œÜs) (n : Option (Fin (c.normalize.length))) :
    (toInvolution' ((consEquiv (œÜ := œÜ)).symm ‚ü®c, n‚ü©)).1 =
    (involutionCons œÜs.length).symm ‚ü®(toInvolution' c).1,
      (uncontractedEquiv' (toInvolution' c).1).symm
      (Option.map (finCongr (toInvolution'_length)) n)‚ü© := by
  erw [toInvolution'_cons]
  rfl

def fromInvolutionAux  : {l : List ùìï} ‚Üí
  (f : {f : Fin l.length ‚Üí Fin l.length // Function.Involutive f}) ‚Üí
    ContractionsAux l (uncontractedFromInvolution f)
  | [] => fun _ =>  ContractionsAux.nil
  | _ :: œÜs => fun f =>
    let f' := involutionCons œÜs.length f
    let c' := fromInvolutionAux f'.1
    let n' := Option.map (finCongr ((uncontractedFromInvolution f'.fst).2.symm))
      (uncontractedEquiv' f'.1 f'.2)
    auxCongr (uncontractedFromInvolution_cons f).symm (ContractionsAux.cons n' c')

def fromInvolution {œÜs : List ùìï} (f : {f : Fin œÜs.length ‚Üí Fin œÜs.length // Function.Involutive f}) :
    Contractions œÜs := ‚ü®uncontractedFromInvolution f, fromInvolutionAux f‚ü©

lemma fromInvolution_cons {œÜs : List ùìï} {œÜ : ùìï}
      (f : {f : Fin (œÜ :: œÜs).length ‚Üí Fin (œÜ :: œÜs).length // Function.Involutive f}) :
    let f' := involutionCons œÜs.length f
    fromInvolution f = consEquiv.symm
    ‚ü®fromInvolution f'.1, Option.map (finCongr ((uncontractedFromInvolution f'.fst).2.symm))
      (uncontractedEquiv' f'.1 f'.2)‚ü© := by
  refine auxCongr_ext ?_ ?_
  ¬∑ dsimp [fromInvolution]
    rw [uncontractedFromInvolution_cons]
    rfl
  ¬∑ dsimp [fromInvolution, fromInvolutionAux]
    rfl

lemma fromInvolution_of_involutionCons
    {œÜs : List ùìï} {œÜ : ùìï}
    (f : {f : Fin (œÜs ).length ‚Üí Fin (œÜs).length // Function.Involutive f})
    (n : { i : Option (Fin œÜs.length) // ‚àÄ (h : i.isSome = true), f.1 (i.get h) = i.get h }):
    fromInvolution (œÜs := œÜ :: œÜs) ((involutionCons œÜs.length).symm ‚ü®f, n‚ü©) =
    consEquiv.symm
    ‚ü®fromInvolution f, Option.map (finCongr ((uncontractedFromInvolution f).2.symm))
      (uncontractedEquiv' f n)‚ü© := by
  rw [fromInvolution_cons]
  congr 1
  simp
  rw [Equiv.apply_symm_apply]




lemma toInvolution_fromInvolution : {œÜs : List ùìï} ‚Üí (c : Contractions œÜs) ‚Üí
    fromInvolution (toInvolution' c) = c
  | [], ‚ü®[], ContractionsAux.nil‚ü© => rfl
  | œÜ :: œÜs, ‚ü®_, .cons (œÜs·µ§‚Çô := œÜs·µ§‚Çô) n c‚ü© => by
    rw [toInvolution'_cons]
    rw [fromInvolution_of_involutionCons]
    rw [Equiv.symm_apply_eq]
    dsimp [consEquiv]
    refine consEquiv_ext ?_ ?_
    ¬∑ exact toInvolution_fromInvolution ‚ü®œÜs·µ§‚Çô, c‚ü©
    ¬∑ simp [finCongr]
      ext a : 1
      simp only [Option.mem_def, Option.map_eq_some', Function.comp_apply, Fin.cast_trans,
        Fin.cast_eq_self, exists_eq_right]

lemma fromInvolution_toInvolution : {œÜs : List ùìï} ‚Üí  (f : {f : Fin (œÜs ).length ‚Üí Fin (œÜs).length // Function.Involutive f})
    ‚Üí toInvolution' (fromInvolution f) = f
  | [], _ => by
    ext x
    exact Fin.elim0 x
  | œÜ :: œÜs, f => by
    rw [fromInvolution_cons]
    rw [toInvolution_consEquiv]
    erw [Equiv.symm_apply_eq]
    have hx := fromInvolution_toInvolution ((involutionCons œÜs.length) f).fst
    apply involutionCons_ext ?_ ?_
    ¬∑ simp only [Nat.succ_eq_add_one, List.length_cons]
      exact hx
    ¬∑ simp only [Nat.succ_eq_add_one, Option.map_map, List.length_cons]
      rw [Equiv.symm_apply_eq]
      conv_rhs =>
        lhs
        rw  [uncontractedEquiv'_cast hx]
      simp  [Nat.succ_eq_add_one,- eq_mpr_eq_cast, Equiv.trans_apply, -Equiv.optionCongr_apply]
      rfl

def equivInvolutions {œÜs : List ùìï} :
    Contractions œÜs ‚âÉ {f : Fin œÜs.length ‚Üí Fin œÜs.length // Function.Involutive f} where
  toFun := fun c =>  toInvolution' c
  invFun := fromInvolution
  left_inv := toInvolution_fromInvolution
  right_inv := fromInvolution_toInvolution

/-- A structure specifying when a type `I` and a map `f :I ‚Üí Type` corresponds to
  the splitting of a fields `œÜ` into a creation `n` and annihlation part `p`. -/
structure Splitting (f : ùìï ‚Üí Type) [‚àÄ i, Fintype (f i)]
    (le : (Œ£ i, f i) ‚Üí (Œ£ i, f i) ‚Üí Prop) [DecidableRel le] where
  /-- The creation part of the fields. The label `n` corresponds to the fact that
    in normal ordering these feilds get pushed to the negative (left) direction. -/
  ùìën : ùìï ‚Üí (Œ£ i, f i)
  /-- The annhilation part of the fields. The label `p` corresponds to the fact that
    in normal ordering these feilds get pushed to the positive (right) direction. -/
  ùìëp : ùìï ‚Üí (Œ£ i, f i)
  /-- The complex coefficent of creation part of a field `i`. This is usually `0` or `1`. -/
  ùìßn : ùìï ‚Üí ‚ÑÇ
  /-- The complex coefficent of annhilation part of a field `i`. This is usually `0` or `1`. -/
  ùìßp : ùìï ‚Üí ‚ÑÇ
  hùìë : ‚àÄ i, ofListLift f [i] 1 = ofList [ùìën i] (ùìßn i) + ofList [ùìëp i] (ùìßp i)
  hùìën : ‚àÄ i j, le (ùìën i) j
  hùìëp : ‚àÄ i j, le j (ùìëp i)

/-- In the static wick's theorem, the term associated with a contraction `c` containing
  the contractions. -/
noncomputable def toCenterTerm (f : ùìï ‚Üí Type) [‚àÄ i, Fintype (f i)]
    (q : ùìï ‚Üí FieldStatistic)
    (le : (Œ£ i, f i) ‚Üí (Œ£ i, f i) ‚Üí Prop) [DecidableRel le]
    {A : Type} [Semiring A] [Algebra ‚ÑÇ A]
    (F : FreeAlgebra ‚ÑÇ (Œ£ i, f i) ‚Üí‚Çê[‚ÑÇ] A) :
    {œÜs : List ùìï} ‚Üí (c : Contractions œÜs) ‚Üí (S : Splitting f le) ‚Üí A
  | [], ‚ü®[], .nil‚ü©, _ => 1
  | _ :: _, ‚ü®_, .cons (œÜs·µ§‚Çô := aux') none c‚ü©, S => toCenterTerm f q le F ‚ü®aux', c‚ü© S
  | a :: _, ‚ü®_, .cons (œÜs·µ§‚Çô := aux') (some n) c‚ü©, S => toCenterTerm f q le F ‚ü®aux', c‚ü© S *
    superCommuteCoef q [aux'.get n] (List.take (‚Üën) aux') ‚Ä¢
      F (((superCommute fun i => q i.fst) (ofList [S.ùìëp a] (S.ùìßp a)))
        (ofListLift f [aux'.get n] 1))

/-- Shows that adding a field with no contractions (none) to an existing set of contractions
  results in the same center term as the original contractions.

  Physically, this represents that an uncontracted (free) field does not affect
  the contraction structure of other fields in Wick's theorem. -/
lemma toCenterTerm_none (f : ùìï ‚Üí Type) [‚àÄ i, Fintype (f i)]
    (q : ùìï ‚Üí FieldStatistic) {œÜs : List ùìï}
    (le : (Œ£ i, f i) ‚Üí (Œ£ i, f i) ‚Üí Prop) [DecidableRel le]
    {A : Type} [Semiring A] [Algebra ‚ÑÇ A]
    (F : FreeAlgebra ‚ÑÇ (Œ£ i, f i) ‚Üí‚Çê A)
    (S : Splitting f le) (œÜ : ùìï) (c : Contractions œÜs) :
    toCenterTerm (œÜs := œÜ :: œÜs) f q le F (Contractions.consEquiv.symm ‚ü®c, none‚ü©) S =
    toCenterTerm f q le F c S := by
  rw [consEquiv]
  simp only [Equiv.coe_fn_symm_mk]
  dsimp [toCenterTerm]
  rfl

/-- Proves that the part of the term gained from Wick contractions is in
  the center of the algebra. -/
lemma toCenterTerm_center (f : ùìï ‚Üí Type) [‚àÄ i, Fintype (f i)]
    (q : ùìï ‚Üí FieldStatistic)
    (le : (Œ£ i, f i) ‚Üí (Œ£ i, f i) ‚Üí Prop) [DecidableRel le]
    {A : Type} [Semiring A] [Algebra ‚ÑÇ A]
    (F : FreeAlgebra ‚ÑÇ (Œ£ i, f i) ‚Üí‚Çê A) [OperatorMap (fun i => q i.1) le F] :
    {œÜs : List ùìï} ‚Üí (c : Contractions œÜs) ‚Üí (S : Splitting f le) ‚Üí
    (c.toCenterTerm f q le F S) ‚àà Subalgebra.center ‚ÑÇ A
  | [], ‚ü®[], .nil‚ü©, _ => by
    dsimp [toCenterTerm]
    exact Subalgebra.one_mem (Subalgebra.center ‚ÑÇ A)
  | _ :: _, ‚ü®_, .cons (œÜs·µ§‚Çô := aux') none c‚ü©, S => by
    dsimp [toCenterTerm]
    exact toCenterTerm_center f q le F ‚ü®aux', c‚ü© S
  | a :: _, ‚ü®_, .cons (œÜs·µ§‚Çô := aux') (some n) c‚ü©, S => by
    dsimp [toCenterTerm]
    refine Subalgebra.mul_mem (Subalgebra.center ‚ÑÇ A) ?hx ?hy
    exact toCenterTerm_center f q le F ‚ü®aux', c‚ü© S
    apply Subalgebra.smul_mem
    rw [ofListLift_expand]
    rw [map_sum, map_sum]
    refine Subalgebra.sum_mem (Subalgebra.center ‚ÑÇ A) ?hy.hx.h
    intro x _
    simp only [CreateAnnihilateSect.toList]
    rw [ofList_singleton]
    exact OperatorMap.superCommute_ofList_singleton_Œπ_center (q := fun i => q i.1)
      (le := le) F (S.ùìëp a) ‚ü®aux'[‚Üën], x.head‚ü©

end Contractions

end Wick
